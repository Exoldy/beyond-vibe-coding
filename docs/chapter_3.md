# Глава 3. Проблема 70%: AI-воркфлоу, которые реально работают

ИИ-инструменты для кодинга чертовски хороши в определенных задачах. Они шикарно генерируют бойлерплейт, пишут рутинные функции и дотаскивают проекты почти до финиша. На деле многие разрабы замечают, что ИИ-ассистент может выкатить первичное решение, закрывающее где-то 70% требований.

Питер Янг в Твиттере (X) идеально описал то, что я наблюдаю в полях:

> Честные мысли не-инженера о кодинге с ИИ на данный момент:
>
> Он довозит тебя на 70% пути, но последние 30% — это адская боль. Постоянно: шаг вперед, два назад, новые баги, проблемы и вот это всё.
>
> Если бы я шарил, как работает код, я бы, наверное, сам пофиксил. Но поскольку я не шарю, я начинаю сомневаться, что вообще чему-то учусь.

Не-технари, использующие ИИ для кодинга, лбом упираются в эту стену. Они пролетают 70% пути удивительно быстро, но финальные 30% превращаются в упражнение по закону убывающей отдачи.

Эта "проблема 70%" вскрывает важную суть текущего состояния ИИ-разработки. Поначалу всё выглядит как магия: описываешь свои хотелки, и тулзы типа v0 или Bolt выплевывают рабочий прототип, который выглядит внушительно. Но потом наступает суровая реальность.

Эти 70% — зачастую самая прямолинейная, шаблонная часть работы. Код, который ходит по протоптанным дорожкам и использует стандартные фреймворки. Как заметил один чел в комментах на Hacker News, ИИ великолепен в управлении "случайной сложностью" софта (рутинная, механическая хрень), в то время как "существенная сложность" — понимание и управление глубинной сложностью проблемы — всё еще лежит на плечах кожаных мешков. Говоря классическими терминами Фреда Брукса, ИИ решает сопутствующие проблемы разработки, но не фундаментальные.

Где эти инструменты лажают? Опытные инженеры постоянно говорят о разрыве "последней мили". ИИ может родить правдоподобное решение, но последние 30% — покрытие граничных случаев (edge cases), шлифовка архитектуры и обеспечение поддерживаемости — "требуют серьезной человеческой экспертизы".

Например, ИИ может выдать функцию, которая технически работает в базовом сценарии, но она не будет автоматически учитывать кривые инпуты, гонки состояний (race conditions), ограничения производительности или будущие требования, если только ты прямым текстом не прикажешь это сделать. ИИ довезет тебя почти до конца, но эти финальные критические 30% (эдж-кейсы, поддерживаемость и нормальная архитектура) требуют скиллов живого спеца.

Более того, у ИИ есть известная склонность генерить убедительную, но некорректную дичь. Он может внедрить неочевидные баги или "сгаллюцинировать" несуществующие функции и либы. Стив Йегге язвительно сравнивает нынешние LLM с "дико продуктивными джунами" — невероятно быстрыми и полными энтузиазма, но "потенциально обдолбанными тяжелыми веществами", склонными изобретать безумные или нерабочие подходы.

По словам Йегге, LLM может выблевать код, который на первый взгляд выглядит прилизанным. Но если неопытный разраб наивно скажет "Вроде норм!" (LGTM) и покатит это в работу, следующие недели превратятся в цирк (или катастрофу). ИИ не понимает проблему по-настоящему; он сшивает паттерны, которые *обычно* имеют смысл. Только человек может разглядеть, не скрывает ли с виду нормальное решение мины замедленного действия. Саймон Уиллисон подтвердил это, увидев, как ИИ предложил дьявольски хитрый дизайн, который только сеньор с глубоким пониманием проблемы мог распознать как дефектный. Урок прост: уверенность ИИ сильно превышает его надежность.

Важно понимать: текущие ИИ не создают фундаментально новые абстракции или стратегии за пределами своих обучающих данных. Они не изобретут для вас новый алгоритм или инновационную архитектуру — они ремиксуют то, что уже известно. И они не несут ответственности за решения. Как заметил один инженер: "У ИИ нет идей 'лучше', чем те, что были в их датасетах. И они не отвечают за свою работу".

Всё это означает, что креативное и аналитическое мышление — решение, *что* строить, *как* структурировать и *зачем* — твердо остается прерогативой человека. Короче говоря, ИИ — это мультипликатор силы для разработчиков, берущий на себя рутинные 70% и дающий нам "турбо-буст" производительности. Но это не серебряная пуля, способная заменить человеческое суждение. Оставшиеся 30% инженерии — самая жесть — всё еще требуют навыков, которые могут привнести только обученные, думающие разработчики. Именно на этих "вечных" навыках стоит фокусироваться, и Глава 4 посвящена им. Как говорилось в одной дискуссии: "ИИ — мощный инструмент, но не волшебная палочка... Человеческое суждение и хорошие инженерные практики всё еще необходимы".

## Как разрабы реально юзают ИИ

Я наблюдаю два четких паттерна в том, как команды используют ИИ. Назовем их "бутстраперы" и "итераторы". Оба помогают инженерам (и даже не-технарям) сократить разрыв между идеей и исполнением (или MVP).

Первые — это **бутстраперы**, которые обычно поднимают новый проект с нуля до MVP. Инструменты вроде Bolt, v0 и "скриншот-в-код" революционизируют то, как эти команды стартуют проекты. Обычно они:

## Начинают с дизайна или чернового концепта
## Используют ИИ для генерации полной начальной кодовой базы
## Получают рабочий прототип за часы или дни вместо недель
## Фокусируются на быстрой валидации и итерациях

Результаты могут впечатлять. Недавно я видел, как соло-разраб с помощью Bolt превратил дизайн из Figma в рабочее веб-приложение практически мгновенно. Это было не "прод-реди", но вполне достаточно для получения самых первых отзывов пользователей.

Второй лагерь, **итераторы**, используют инструменты вроде Cursor, Cline, Copilot и Windsurf в своем повседневном рабочем процессе. Это менее хайпово, но потенциально более трансформационно. Эти разработчики:

## Используют ИИ для автокомплита и подсказок
## Припрягают ИИ для сложных задач по рефакторингу
## Генерируют тесты и документацию
## Используют ИИ как "парного программиста" для решения проблем

Но тут есть подвох: хотя оба подхода могут дико ускорить разработку, у них есть скрытая цена, которая не сразу бросается в глаза.

Когда смотришь, как сеньор работает с тулзами типа Cursor или Copilot, это выглядит как магия. Они могут скаффолдить (набрасывать структуру) целые фичи за минуты, с тестами и доками. Но приглядись внимательнее, и ты заметишь кое-что важное: они не просто принимают то, что предлагает ИИ. Они постоянно рефакторят сгенерированный код, разбивая его на мелкие, сфокусированные модули. Они добавляют нормальную обработку ошибок и эдж-кейсов, которые ИИ пролюбил, усиливают типизацию и интерфейсы, и ставят под сомнение архитектурные решения машины. Другими словами, они применяют годы выстраданной инженерной мудрости, чтобы формировать и ограничивать выхлоп ИИ. ИИ ускоряет их реализацию, но именно их экспертиза делает код поддерживаемым.

## Типичные паттерны провала

Джуниоры часто пропускают эти критические шаги. Они принимают результат ИИ с большей готовностью, что приводит к тому, что я называю "кодом карточного домика" — он выглядит законченным, но складывается под реальной нагрузкой.

## Шаг вперед, два назад

То, что происходит дальше, обычно следует предсказуемому антипаттерну, который я называю "два шага назад" (показан на Рис. 3-1):

1.  Ты пытаешься пофиксить мелкий баг.
2.  ИИ предлагает изменение, которое кажется разумным.
3.  Этот фикс ломает что-то другое.
4.  Ты просишь ИИ пофиксить новую проблему.
5.  Это создает еще две проблемы.
6.  Повторять до посинения.

> [!NOTE]
> **Image Missing**
> *Рис. 3-1. Антипаттерн "два шага назад".*

Этот цикл особенно мучителен для не-инженеров, потому что у них нет ментальных моделей, чтобы понять, что, черт возьми, происходит. Когда опытный разраб натыкается на баг, он может рассуждать о причинах и решениях, опираясь на годы распознавания паттернов. Без этого бэкграунда ты, по сути, играешь в "удари крота" (whack-a-mole) с кодом, который не до конца понимаешь. Это "парадокс знаний", о котором я упоминал в предисловии: сеньоры используют ИИ, чтобы ускорить то, что они *уже умеют* делать, в то время как джуны пытаются использовать его, чтобы научиться тому, *что* делать.

Этот цикл особенно болезнен для не-технарей, использующих ИИ в режиме "бутстрапера", так как им не хватает ментальных моделей для решения проблем при сборке MVP. Однако даже опытные "итераторы" могут попасть в эту ловушку, если будут слишком полагаться на предложения ИИ без глубокой проверки.

Здесь есть проблема поглубже: то самое, что делает ИИ-кодинг доступным для не-инженеров — его способность брать на себя сложность — на самом деле может мешать обучению. Когда код просто "появляется", а ты не понимаешь лежащих в его основе принципов, ты не качаешь скилл отладки. Ты упускаешь изучение фундаментальных паттернов. Ты не можешь рассуждать об архитектурных решениях, и поэтому тебе трудно поддерживать и развивать код. Это создает зависимость: тебе приходится снова и снова бежать к ИИ, чтобы пофиксить проблемы, вместо того чтобы развивать экспертизу для их самостоятельного решения.

Этот риск зависимости выходит на новый уровень с появлением автономных ИИ-агентов для кодинга — тему, которую я глубоко копаю в Главе 10. В отличие от текущих инструментов, которые просто предлагают сниппеты, эти агенты представляют собой фундаментальный сдвиг в разработке софта. Пока я пишу эти строки, мы наблюдаем раннее внедрение систем, способных самостоятельно планировать, выполнять и итерировать целые задачи разработки с минимальным надзором человека.

Эта эволюция от ассистирующего к автономному ИИ ставит серьезные вопросы об экспертизе и контроле разработчика. Когда ИИ-система может тащить полные рабочие процессы — от реализации до тестов и деплоя — риск атрофии навыков становится острым. Разработчики, которые слишком сильно полагаются на этих агентов, не поддерживая свои фундаментальные знания, могут оказаться неспособными эффективно аудировать, направлять или вмешиваться, когда решения ИИ начнут расходиться с желаемым результатом.

Проблема усугубляется, если учесть, как эти автономные системы принимают каскадные решения на протяжении проекта. Каждый отдельный выбор может казаться разумным в изоляции, но кумулятивный эффект может увести разработку совсем не туда. Без экспертизы, позволяющей распознать и скорректировать эти сдвиги траектории на раннем этапе, команды рискуют построить всё более сложные системы на фундаменте, который они не до конца понимают.

Как мы увидим позже, приход автономных кодинг-агентов не уменьшает важность основ программной инженерии — он её усиливает. Чем мощнее наши ИИ-инструменты, тем критичнее сохранять экспертизу, чтобы оставаться архитекторами наших систем, а не просто операторами. Только через глубокое понимание принципов софта мы можем гарантировать, что эти замечательные инструменты расширяют наши возможности, а не размывают их.

## Ловушка демо-качества

Это становится паттерном: команды используют ИИ, чтобы быстро клепать впечатляющие демки. "Счастливый путь" (happy path) работает идеально. Инвесторы и соцсети в восторге. Но когда реальные пользователи начинают тыкать кнопки? Вот тут всё и разваливается.

Я видел это своими глазами: сообщения об ошибках, которые не имеют смысла для нормальных людей, эдж-кейсы, крашащие приложение, запутанные состояния UI, которые так и не почистили, полностью забытая доступность (accessibility) и проблемы с производительностью на медленных девайсах. Это не просто баги с низким приоритетом — это разница между софтом, который люди терпят, и софтом, который они любят.

Создание по-настоящему "самообслуживаемого" софта — такого, где юзерам никогда не нужно писать в саппорт — требует другого мышления, завязанного на утраченном искусстве "полировки". Тебе нужно быть одержимым текстами ошибок; тестировать на медленном интернете и с реальными, нетехническими пользователями; делать фичи обнаруживаемыми; и грациозно обрабатывать каждый эдж-кейс. Такое внимание к деталям (пока что) не может быть сгенерировано ИИ. Оно рождается из эмпатии, опыта и глубокой заботы о ремесле.

## Что реально работает: Практические паттерны воркфлоу

Прежде чем мы нырнем в кодинг в Части II этой книги, нам нужно поговорить о современных практиках разработки и о том, как AI-assisted кодинг вписывается в командный процесс. Разработка софта — это ведь больше, чем просто написание кода. Это целый воркфлоу, включающий планирование, коллаборацию, тестирование, деплой и поддержку. И вайб-кодинг — это не какая-то отдельная диковинка; его можно вплести в гибкие методологии (Agile) и практики DevOps, повышая продуктивность команды и сохраняя качество и надежность.

В этом разделе мы разберем, как члены команды могут коллективно использовать инструменты вайб-кодинга, не наступая друг другу на пятки, как балансировать предложения ИИ с человеческим инсайтом, и как пайплайны CI/CD могут включать ИИ или адаптироваться к сгенерированному коду. Я также затрону важные моменты, вроде стратегий контроля версий.

Понаблюдав за десятками команд, я выделил три паттерна, которые стабильно работают как в соло, так и в командных процессах:

## ИИ как автор черновика (First drafter)
ИИ-модель генерирует начальный код, а разработчики затем его дорабатывают, рефакторят и тестируют.

## ИИ как парный программист (Pair programmer)
Разработчик и ИИ находятся в постоянном диалоге, с короткими петлями обратной связи, частым код-ревью и минимальным контекстом.

## ИИ как валидатор (Validator)
Разработчики сами пишут начальный код, а затем используют ИИ для валидации, тестов и улучшений (см. Рис. 3-2).

> [!NOTE]
> **Image Missing**
> *Рис. 3-2. Воркфлоу ИИ-валидации: разработчики пишут начальный код; ИИ-системы анализируют его на баги и проблемы безопасности, затем предлагают улучшения; разработчики ревьюят и применяют рекомендации.*

В этом разделе я проведу вас через каждый паттерн, обсуждая рабочие процессы и советы для успеха.

## ИИ как автор черновика

Важно убедиться, что все в команде на одной волне, прежде чем просить ИИ набросать какой-либо код. Коммуникация — это ключ, чтобы разработчики не просили своих ИИ-ассистентов делать дублирующую работу или генерировать конфликтующие реализации.

На дейли-стендапах (классика Agile) стоит обсуждать не только то, над чем вы работаете, но и планируете ли вы использовать ИИ для определенных задач. Например, два разраба могут пилить разные фичи, которые обе требуют утилиту для форматирования дат. Если оба попросят ИИ создать хелпер `formatDate`, вы можете получить две похожие функции. Координация на старте ("Я сгенерю утилиту для дат, которую мы оба сможем юзать") предотвратит дублирование.

Команды, успешно внедряющие ИИ-тулзы, часто начинают с согласования стандартов кодирования и практик промптинга. Например, команда может решить придерживаться единого стиля (правила линтинга, конвенции проекта) и даже скормить эти гайдлайны своим ИИ-инструментам (некоторые ассистенты позволяют задавать предпочтения по стилю или примеры кода для корректировки выдачи). Как отмечено в блоге Codacy, знакомя ИИ со стандартами команды, вы получаете сгенерированный код, который более единообразен и с которым всем проще работать. На практике это может означать наличие раздела в README проекта "Советы по использованию ИИ", где вы пишете вещи вроде "Мы используем только функциональные компоненты" или "Предпочитаем Fetch API вместо Axios", чтобы разработчики держали это в голове при общении с ИИ.

Еще одна практика — использовать функции коллаборации ваших инструментов, если они есть. Некоторые AI-assisted IDE позволяют шарить сессии или хотя бы промпты. Если Разработчик А получил отличный результат с промптом для сложного компонента, шеринг этого промпта с Разработчиком Б (через трекер задач или командный чат) сэкономит время и обеспечит консистентность.

Что касается контроля версий, фундамент остается прежним — но с нюансом. Использование Git (или другой VCS) не обсуждается в современной разработке, и это не меняется с вайб-кодингом. На самом деле, контроль версий становится еще важнее, когда ИИ быстро генерит код. Коммиты работают как страховочная сетка для отлова косяков ИИ; если сгенерированное изменение что-то ломает, можно откатиться.

Одна из стратегий — коммитить чаще при использовании помощи ИИ. Каждый раз, когда ИИ выдает значительный кусок кода (типа генерации фичи или крупного рефакторинга), который вы принимаете, делайте коммит с внятным сообщением. Частые коммиты гарантируют, что если вам нужно будет искать причину бага (bisect) или отменять часть кода от ИИ, история будет достаточно детальной.

Также старайтесь изолировать разные изменения от ИИ. Если позволить ИИ внести кучу правок в разных местах и закоммитить всё скопом, будет сложнее распутать клубок, если что-то пойдет не так. Например, если вы используете агента для оптимизации производительности, и он попутно правит тексты в UI, коммитьте это раздельно. (Ваши два сообщения коммитов могут быть "Optimize list rendering performance [AI-assisted]" и "Update UI copy for workout completion message [AI-assisted]"). Описательные сообщения важны; некоторые команды даже тегают коммиты, где было много ИИ, просто для отслеживаемости. Это не для того, чтобы кого-то винить, а чтобы понимать происхождение кода — коммит с тегом `[AI]` может сигнализировать ревьюеру, что код стоит проверить с тройным пристрастием на предмет эдж-кейсов.

По сути, команда должна относиться к использованию ИИ как к нормальной части рабочего разговора: делитесь опытом, удачными техниками и предупреждениями о том, чего делать не стоит (типа "Copilot предлагает юзать устаревшую либу для X, так что аккуратнее").

Ревью и доработка критичны для этого паттерна. Разработчики должны вручную просматривать и рефакторить код для модульности, добавлять исчерпывающую обработку ошибок, писать тщательные тесты и документировать ключевые решения по ходу пьесы. Следующая глава подробно описывает эти процессы.

## ИИ как парный программист

Традиционное парное программирование подразумевает двух людей, работающих за одним компом. С приходом ИИ появился гибридный подход: один человек-разработчик работает бок о бок с ИИ-ассистентом. Этот сетап может быть особенно эффективным, предлагая смесь человеческой интуиции и машинной эффективности.

В паре "человек-ИИ" разработчик взаимодействует с ИИ для получения предложений кода, одновременно проверяя и дорабатывая результат. Эта динамика позволяет человеку использовать скорость ИИ в рутинных задачах, таких как написание бойлерплейта или генерация тест-кейсов, сохраняя при этом контроль над качеством и релевантностью кода.

Например, при интеграции новой библиотеки разработчик может попросить ИИ набросать начальный код интеграции. Затем он проверяет предложения ИИ, сверяясь с официальной документацией для точности. Этот процесс не только ускоряет разработку, но и способствует получению знаний, так как разработчик глубоко погружается и в выдачу ИИ, и в тонкости библиотеки.

Давайте сравним это с традиционным парным программированием "человек-человек":

**Пара Человек-ИИ** предлагает быструю генерацию кода и эффективно справляется с рутиной. Это особенно выгодно для соло-разработчиков или когда ресурсы команды ограничены.

**Пара Человек-Человек** превосходит в решении сложных проблем, где необходимо нюансированное понимание и совместный мозговой штурм. Это способствует разделению ответственности и коллективному пониманию кода.

Оба подхода имеют свои плюсы, и выбор между ними может зависеть от сложности проекта, доступности ресурсов и конкретных целей процесса разработки.

## Лучшие практики для ИИ-пейринга

Чтобы выжать максимум из AI-assisted разработки, рассмотрите следующие практики:

## Начинайте новые ИИ-сессии для отдельных задач
Это помогает сохранять чистоту контекста и гарантирует, что предложения ИИ релевантны конкретной задаче.

## Держите промпты сфокусированными и краткими
Предоставление четких и конкретных инструкций повышает качество выдачи ИИ.
## Чаще ревьювь и пушь коммиты
Регулярная интеграция и тестирование кода, который высрала нейронка, помогают отлавливать баги на ранних стадиях и не ронять темп проекта.

## Держи петлю обратной связи короткой
Постоянно оценивай, что там ИИ нагенерил. Пинай его, давай исправления и уточнения — пусть учится, собака, чтобы в следующий раз выдал что-то более вменяемое.

## ИИ как контролёр (валидатор)
ИИ годится не только чтобы код писать, он ещё и отличный душнила-контролёр. Он может помочь с код-ревью и QA. Инструменты на базе ИИ способны просканировать код на баги, дыры в безопасности и соответствие бест-практис. Например, платформы вроде DeepCode или чекера от Snyk могут ткнуть тебя носом в отсутствие санитайзинга инпутов или дырявые конфиги прямо в IDE. А ребята типа Qodo и TestGPT могут автоматически нагенерить тест-кейсов, чтобы покрыть код тестами и сэкономить тебе кучу времени. Плюс, многие ИИ-тулзы умеют мониторить перфоманс приложения и орать, если появляются аномалии, намекающие на скрытые проблемы.

Встраивая ИИ-валидаторов в рабочий процесс, команды могут подтянуть качество кода, снизить вероятность факапов и закрыть вопросы по безопасности. Этот проактивный подход дополняет (а не заменяет!) человеческий надзор, делая софт более надёжным. Эти инструменты берут на себя всю нудную и рутинную работу в QA, позволяя кожаным тестировщикам сосредоточиться на реальных проблемах и сложных нюансах.

Внедрение ИИ в процесс разработки — будь то в роли парного прогера или валидатора — реально бустит продуктивность и качество. Но только если подходить к этому с умом, объединяя сильные стороны человеческого и искусственного интеллекта.

Чтобы выжать максимум из этого союза в QA, рекомендую пару проверенных практик:

*   Используй ИИ для первичного сканирования и поиска очевидных косяков.
*   Оставь людям ревью критически важных зон: сложной функциональности, UX и тех моментов, где ИИ обычно тупит.
*   Создавай среду постоянного сотрудничества, где ИИ-тулзы и живые тестировщики работают в тандеме, постоянно обмениваясь фидбеком для прокачки и тех, и других.

## Золотые правила Вайб-кодинга
Хоть вайб-кодинг и даёт дикую скорость и свободу, без структуры это прямой путь в ад. Быстрая, интуитивная природа ИИ-разработки может моментально превратить проект в хаос, если нет чётких гайдлайнов, балансирующих творческий угар и инженерную дисциплину.

Эти золотые правила написаны кровью и потом команд, которые успешно внедрили вайб-кодинг и выжили. Это выстраданное понимание того, где ИИ красавчик, а где спотыкается, и почему человеческая "чуйка" всё ещё незаменима. Эти принципы не душат креатив, а создают рамки, в которых можно смело экспериментировать, не роняя прод.

Правила покрывают три критических фронта: взаимодействие "человек-ИИ", интеграция сгенерированного кода и командные процессы. Следуй им, и ты оседлаешь вайб-кодинг, избежав техдолга, дыр в безопасности и спагетти-кода, который невозможно поддерживать:

## Будь конкретен и чёток в своих хотелках
Ясно формулируй требования, задачи и ожидаемый результат при общении с ИИ. Точный промт — точный результат. Говно на входе — говно на выходе.

## Всегда сверяй выхлоп ИИ со своим замыслом
Код от нейронки всегда нужно чекать на соответствие твоей изначальной цели. Проверяй функционал, логику и адекватность, прежде чем тащить это к себе.

## Относись к ИИ как к джуну (за которым нужен глаз да глаз)
Считай всё, что выдал ИИ, черновиком. Ревьювь, правь, давай по шапке и следи за качеством.

## Юзай ИИ для расширения возможностей, а не отключения мозга
Спихни на ИИ рутину или сложные, но типовые задачи, но сам оставайся включённым в решение проблем и принятие решений.

## Договоритесь "на берегу" всей командой
Синхронизируйтесь по стандартам использования ИИ, ожиданиям от кода и практикам *до того*, как начнёте безудержно генерить.

## Сделай ИИ нормальной темой для разговора
Регулярно обсуждайте успехи, факапы, новые фишки и подводные камни. ИИ — это просто ещё один инструмент для общего блага, не делайте из этого табу.

## Изолируй изменения от ИИ в отдельных коммитах
Мухи отдельно, котлеты отдельно. Чётко помечай изменения, сделанные ИИ, в системе контроля версий. Так проще делать ревью, откатывать и трекать, кто (или что) накосячило.

## Весь код, человеческий или машинный, должен проходить ревью
Поддерживай единые стандарты: любой вклад в репозиторий должен проходить через ту же мясорубку ревью. Это держит качество и понимание кода командой на уровне.

## Не мержи код, который не понимаешь
Никогда не вливай сгенерированный код, если ты досконально не врубаешься, как он работает и к чему это приведёт. Понимание — ключ к поддерживаемости и безопасности. Если ты это замержил, ты за это отвечаешь.

## Приоритет на документацию, комменты и ADR
Чётко документируй "почему", "как" и контекст для кода от ИИ. Хорошая дока спасёт тебя от похмелья через полгода и снизит будущий техдолг.

## Делись и переиспользуй рабочие промты
Записывай промты, которые выдают годноту. Ведите базу проверенных промтов, чтобы не изобретать велосипед каждый раз.

## Рефлексируй и итерируй
Периодически пересматривай свой процесс работы с ИИ. Используй опыт прошлых факапов, чтобы постоянно улучшать подход команды.

Соблюдая эти правила, ваша команда сможет эффективно юзать ИИ, повышая продуктивность, но сохраняя ясность, качество и контроль над ситуацией.

## Итоги и следующие шаги
Проблема "70%" определяет текущее состояние ИИ-разработки: эти инструменты отлично клепают бойлерплейт и рутинные функции, но сливаются на последних 30% — корнер-кейсах, архитектурных решениях и подготовке к проду. Мы выделили два основных паттерна использования: "бутстраперы" (быстро лепят MVP) и "итераторы" (встраивают ИИ в повседневку). А также вспомнили типичные грабли, вроде антипаттерна "два шага назад" и ловушки "демо-качества", когда впечатляющий прототип разваливается под реальной нагрузкой.

Вырисовались три рабочих сценария: ИИ как черновик (сгенерил — допилил), ИИ как парный прогер (постоянный диалог) и ИИ как валидатор (ты пишешь, он чекает). Золотые правила вайб-кодинга — это ваши отбойники на трассе: чёткая коммуникация, жёсткая валидация, командная координация и железное правило "не понимаешь — не мержишь".

Каждому разрабу стоит выбрать один паттерн и систематически его обкатывать, применяя золотые правила. Фокусируйтесь на прокачке "вечных" скиллов из 4-й главы: системный дизайн, дебаггинг и архитектура. Не пытайтесь соревноваться с ИИ в написании кода — станьте его боссом.

Командам нужно установить стандарты, создать общие базы промтов и интегрировать ИИ в свои аджайл-процессы. Регулярный обмен знаниями об успехах и провалах поможет не наступать на одни и те же грабли.

С появлением автономных ИИ-агентов роль человека смещается в сторону архитектурного надзора и стратегических решений. В следующей главе мы разберем, как максимизировать этот незаменимый человеческий вклад, чтобы инженеры любого уровня процветали как партнёры всё более мощных ИИ-систем, а не как их конкуренты.

---
*1 Эта глава основана на эссе, изначально опубликованном в моей рассылке на Substack. См. Addy Osmani, “The 70% Problem: Hard Truths About AI-Assisted Coding”, Elevate with Addy Osmani, December 4, 2024.*
