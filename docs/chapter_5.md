# Глава 5. Понимание сгенерированного кода: Ревью, Допил, Оунершип

Ты уже научился уламывать AI генерировать код, и к этому моменту наверняка уже что-то накодил с помощью этих техник. Теперь наступает критическая фаза: убедиться, что этот код корректен, безопасен и пригоден для поддержки.

Как разработчик, ты не можешь просто взять выхлоп AI и с тупой лыбой катить его в прод. Тебе нужно его отрецензировать, протестировать, возможно, улучшить и интегрировать с остальной кодовой базой. Эта глава посвящена тому, как вдуплить в то, что тебе выдал AI, итеративно отредактировать и отладить это, и полностью взять на себя ответственность за этот код как часть твоего проекта.

В этой главе мы разберем:
## Интерпретация кода AI с точки зрения твоего изначального замысла

Феномен «решения большинства», или почему сгенерированный код часто выглядит как самая попсовая копипаста.
## Техники ревью кода на предмет ясности и скрытых косяков
## Отладка кода, написанного AI, когда он работает не так, как ожидалось
## Рефакторинг кода ради стиля или эффективности
## Написание тестов для валидации поведения кода

Освоив эти навыки, ты сможешь уверенно вливать вклад AI в свои проекты.

## От замысла к реализации: Понимание интерпретации AI
Когда ты получаешь код от AI, твой первый шаг — сравнить его с твоим замыслом (промтом, который ты скормил). Выполняет ли код требования, которые ты поставил? Иногда AI может слегка не так понять задачу или реализовать её лишь частично.

Внимательно прочти код. Прокрути его в голове или на бумажке:

Протрекай, что он делает для типичного ввода.

Если в твоем промте было несколько частей («сделай X и Y»), проверь, что AI выполнил их все.

Убедись, что AI не добавил функциональность, которую ты не просил — иногда он лепит фичи, которые «считает» полезными, типа лишнего логирования или левого параметра. Это может быть ок, а может и нет.

Так же, как ты бы поступил с кодом коллеги: если что-то непонятно, сделай пометку. Если ты найдешь вескую причину для этого куска — отлично. Если нет — задай вопрос или подумай о том, чтобы выпилить это.

Например, если ты просишь чекер простых чисел, а код AI также печатает что-то вроде «Проверяю 7…» для каждого числа, это может быть артефактом того, как ты составил промт, или паттерном из обучающих данных (в некоторых туториалах код печатает прогресс). Если тебе этот мусор в консоли не нужен, планируй его удалить или попроси AI убрать это.

Также убедись, что граничные случаи (edge cases) обрабатываются так, как ты ожидаешь. Если ты хотел, чтобы код переваривал пустой ввод, делает ли он это? Если ввод может быть `None` или отрицательным числом, учел ли это AI?

Если что-то в твоем промте было двусмысленным, и AI пришлось выбирать интерпретацию, найди это место. Возможно, ты не указал формат вывода, и он решил печатать результаты вместо того, чтобы возвращать их. Теперь тебе решать: принять это как есть или переписать код.

Эта фаза понимания критически важна; не скипай её. Даже если ты собираешься тестировать код, понимание через чтение важно, потому что тесты могут не покрыть всё (а чтение быстрее выявляет очевидные ляпы).

И последнее: учитывай допущения AI. Искусственный интеллект часто стремится к «большинству» или самой распространенной интерпретации (что подводит нас к следующему разделу).

## Проблема «Большинства»: Самое популярное — не значит самое подходящее
Модели AI, обученные на тоннах кода, часто выдают решение, которое наиболее широко представлено в этих обучающих данных (или самое простое решение, которое подходит). Я называю это эффектом решения большинства. Оно корректно в общих случаях, но может быть не лучшим вариантом для твоей конкретной ситуации.

Например, если ты попросишь алгоритм поиска без дополнительного контекста, AI может выдать базовый линейный поиск, потому что это прямолинейно и популярно. Возможно, тебе на самом деле нужен был бинарный поиск, но AI не знал, что эффективность критична, потому что ты об этом промолчал. Линейный поиск прокатит во многих средних случаях, но не там, где перформанс — это наше всё.

Точно так же AI может использовать глобальную переменную, потому что во многих простых примерах так делают, но, возможно, в твоем проекте это считается говнокодом.

Помни, что решение AI может быть оптимизировано под сферический сценарий в вакууме. Как живой разработчик, ты обладаешь пониманием контекста, которого нет у AI.

Чтобы с этим бороться:

Идентифицируй допущения в коде. Если код предполагает, что список отсортирован или ввод валиден, было ли это допущение ок? Ты это указывал? Если нет, возможно, стоило добавить проверку.

Рассмотри альтернативы: Если ты знаешь несколько способов решения задачи (например, разные алгоритмы), выбрал ли AI тот самый? Тот ли это, который тебе нужен? Если нет, можешь запросить альтернативу или просто поменять сам.

Если код AI работает для «обычного» случая, но не для граничных условий, которые важны для тебя — это надо фиксить. Например, может, он не учел переполнение целого числа в какой-то математике. Во многих обучающих примерах на это забивали болт, но в твоем контексте это может быть фатально.

Понимание того, что AI тяготеет к дженерик-решениям, сделает тебя лучше в ревью его кода. Это не магия и не индпошив; это очень обоснованная догадка о решении. Подгонка по фигуре — это твоя работа.

## Читаемость кода и структура: Паттерны и потенциальные проблемы
Сгенерированный AI код часто имеет палевные паттерны. Он может:

Включать больше комментов, чем обычно, или странно сформулированные комменты (так как он учился на коде из туториалов, который обычно закомментирован до смерти).

Использовать определенные имена переменных постоянно (типа `i`, `j`, `k` для циклов).
## Раскладывать код в несколько многословном стиле (чтобы покрыть общие случаи)

Чекай эти моменты и смотри, соответствуют ли они стилю твоего проекта. Код может быть функционально рабочим, но требовать прохода на читаемость. В этом проходе ты, возможно, захочешь:

Переименовать переменные, чтобы они были более описательными или соответствовали твоему кодстайлу.

Удалить или причесать комменты. Если он добавил коммент типа `# проверить, является ли число простым` над самоочевидным `if`, можешь смело это сносить. Но если там коммент, объясняющий сложный кусок логики, это гуд — оставь или улучши.

Обеспечить консистентное форматирование, прогнав код через линтер или форматтер (типа Black для Python или gofmt для Go), чтобы подогнать отступы и скобки под ваши стандарты.

Также ищи любую необычную структуру. Определил ли AI несколько классов или функций, когда ты ожидал одну? Иногда он может разбить задачу на несколько функций, потому что так было в обучающем примере. Если это оверкилл, можешь заинлайнить их (или наоборот). Код слишком умный или слишком наивный? AI иногда выдает очень прямолинейное решение или, изредка, вычурный однострочник. Совпадает ли это с предпочтениями твоей команды? Если нет — правь.

Другие потенциальные проблемы, за которыми надо следить:
## Ошибки на единицу (Off-by-one errors)
Да, AI тоже может лажать в этом. Например, границы циклов могут быть хитрыми. Если есть время, ментально прогони простой кейс через цикл.
## Необработанные исключения
Предполагает ли код, что файл откроется успешно или что весь ввод в правильном формате? Добавь обработку ошибок, если нужно.
## Ловушки производительности
Может быть, AI использует вложенный цикл на большом датасете для проверки принадлежности, хотя существует лучший подход, например, использование множества (`set`). Решение AI может быть правильным, но не оптимальным.
## Использование библиотек
Если код использует библиотеку, убедись, что это та, которую ты хочешь использовать (и что она вообще доступна). Иногда он может заюзать, скажем, `numpy` для простой суммы (потому что видел это в примерах в своих обучающих данных). Если тащить эту зависимость не стоит свеч, переключись на чистый Python или библиотеку, которую ты планировал.
## Несоответствия
Иногда код AI может иметь мелкие несоответствия, например, докстринг функции говорит одно, а код делает другое (если он переписал логику, но не коммент, например). Пофикси это.
## Мелкие синтаксические проблемы
Это редкость с хорошо протестированными моделями, но не невозможно в языках, где что-то может запутать.
## Использование устаревших API
AI может использовать старую версию библиотечной функции, которая изменилась. Если видишь вызов функции, который не узнаешь, быстро чекни доки библиотеки, чтобы убедиться, что он корректен для твоей версии.
## Плейсхолдеры
Если выхлоп AI использует заглушки типа «Ваш код здесь» (редко, но бывает в дженерик-шаблонах), заполни их.

Короче говоря, относись к коду AI так, будто его написал стажер и свалил домой на выходные. Тебе нужно отрецензировать его на качество и правильно интегрировать.

## Стратегии отладки: Поиск и исправление ошибок
Допустим, ты запустил код (или написал тесты для него, что мы скоро обсудим), и что-то не работает. Отладка кода от AI ничем не отличается от отладки твоего собственного или чужого кода — за исключением того, что не ты его писал, поэтому ты можешь быть менее знаком с ним. Но поскольку ты его уже внимательно прочитал, ты в хорошей форме (см. Рисунок 5-1).

> [!NOTE]
> **Изображение отсутствует**
> *Рисунок 5-1. Цикл отладки кода AI: выполнение сгенерированного AI кода, отлов ошибок, предоставление контекста ошибки обратно AI для анализа, внедрение предложенных исправлений и итерации до победного.*

Вот шестишаговый подход к отладке:

Воспроизведи проблему.

Запусти функцию или код с входными данными, которые вызывают сбой. Понаблюдай за выводом или ошибкой.

Локализуй источник проблемы.

Используй типичные техники отладки, типа `print`-ов, или используй дебаггер, чтобы пройтись пошагово. Если это логическая ошибка (неверный вывод), протрекай логику вручную или с принтами, чтобы увидеть, где она расходится с твоими ожиданиями.

Проверь промт относительно кода.

Иногда баг просто в том, что код не полностью реализовал требование, например, если ты просил отсортировать что-то, а оно не сортируется нормально. Это может означать, что логика AI ошибочна или что граничный случай (типа пустого списка) не обрабатывается.

Используй AI для дебага!

Ты реально можешь скормить проблемный код обратно в AI и сказать: «Этот код выдает неверный результат для X. Можешь помочь найти баг?» Часто он проанализирует это (как на код-ревью) и укажет на проблемы. Например, может заметить, что цикл должен идти до `len(arr)`, а идет до `len(arr)-1`. Он может отловить это быстрее. (Будь осторожен и не доверяй ему полностью — но это как попросить коллегу помочь с дебагом).

Пофикси код.

Теперь у тебя есть выбор: пофиксить вручную или попросить AI выдать исправленную версию. Если фикс очевиден, просто сделай это. Если нет, можешь попробовать что-то вроде «Функция выше падает на вводе X (ожидалось Y, получено Z). Пожалуйста, исправь это». AI может скорректировать код соответствующим образом.

Протестируй снова.

Убедись, что баг устранен и новые проблемы не вылезли.

Я рекомендую использовать отладку через тесты (test-driven debugging). Если возможно, напиши несколько тестов для критических функций (подробнее об этом в разделе про тестирование позже в этой главе). Любые упавшие тесты прямо укажут, что не так. Это может быть быстрее ручной проверки для всего, кроме самых простейших функций.

Наконец, при отладке убедись, что ты спрашиваешь «почему», а не только «что». Постарайся понять, почему AI совершил ошибку. Был ли промт неясным в этом моменте? Это может подсказать, как промтить в следующий раз или нужно ли всегда перепроверять этот аспект в выхлопах AI. Например, если ты заметишь, что AI часто не обрабатывает пустой ввод, пока ему не скажешь, ты начнешь всегда указывать это в промтах и проверять при ревью.

## Рефакторинг для поддерживаемости: Делаем код AI своим кодом
Как только код функционально корректен, рассмотри его рефакторинг, чтобы подогнать под стандарты твоего проекта и облегчить работу с ним в будущем. Работа AI заключалась в том, чтобы дать тебе код быстро; твоя работа — отполировать его.

Вот еще один шестишаговый процесс, на этот раз для рефакторинга:

Выровняй со стайлгайдом.

Прогони код через свой форматтер или линтер. Исправь любые варнинги типа «Имя переменной должно быть в нижнем регистре» или «Строка слишком длинная». Это мгновенно заставит код выглядеть как остальная часть твоей кодовой базы. Многие инструменты AI делают неплохую работу со стилем, но легкие корректировки могут понадобиться.

Улучши нейминг и структуру.

Если AI назвал функции `_helper1` и `_helper2` в классе, а ты предпочитаешь осмысленные имена, переименуй их. Если он создал кучу мелких функций, которые используются только один раз, может, стоит их заинлайнить, если только они не добавляют ясности.

Удали любые ненужные части.

Например, возможно, AI включил блок `main` или тестовый код в вывод, который ты не просил. Если тебе это не нужно, удаляй. И наоборот, может быть, он написал всё в одной функции, но ты хочешь разбить это на более мелкие куски для ясности; если так, делай сплит сейчас.

Добавь документацию.

Если этот код предназначен стать частью библиотеки или модуля, который будут использовать другие, добавь докстринги или комменты, где уместно. AI мог что-то прокомментировать, но убедись, что это соответствует твоим стандартам. Например, может, твой проект требует определенного формата докстринга с документированием параметров и возвращаемых значений.

Оптимизируй, если нужно.

Теперь, когда код работает, достаточно ли он эффективен? Если этот код будет вызываться в жестком цикле или на больших данных, проверь его сложность. AI мог не использовать самый оптимальный подход (опять же, «решение большинства» может быть простым циклом, а не более оптимизированным подходом). Если производительность вызывает беспокойство, отрефактори на лучший алгоритм. Ты снова можешь привлечь AI:

Оптимизируй этот код, чтобы он работал быстрее, используя `set` вместо `list` для лукапов.

Но ты, как разработчик, часто знаешь, какой паттерн тебе нужен, так что можешь просто реализовать это изменение сам.

Упрости, если нужно.

Иногда код AI может быть чрезмерно многословным. Например, он может использовать `if-else` с `return`-ами там, где хватило бы одного `return` с условием. Хотя явный код — это не обязательно плохо, ты можешь захотеть упростить его до меньшего количества строк, чтобы улучшить читаемость без потери ясности.

Цель рефакторинга в том, чтобы, если другой разработчик откроет этот код позже, не было очевидно, что «это написал AI». Это должно просто выглядеть как хороший код. Это часто означает добавление тех небольших человеческих штрихов, которые делают код чистым.

Когда ты рефакторишь, тебе нужно убедиться, что ты ничего не сломал. Так что давай перейдем к тестированию.

## Важность тестирования: Юнит, Интеграционные и E2E
Тестирование всегда важно, но для кода, сгенерированного AI, оно особенно важно по двум причинам. Во-первых, поскольку не ты писал его с нуля, тебе нужны гарантии, что он сработает во всех случаях. Во-вторых, если ты позже попросишь AI внести изменения или интегрируешь больше AI-кода, тесты помогут убедиться, что любые новые изменения не сломают существующую функциональность. Давай быстро глянем на разные виды тестов:
## Юнит-тесты
Пиши тесты для каждой функции или модуля, полученного от AI, особенно покрывая граничные случаи (edge cases). Для нашего примера с простыми числами ты можешь протестировать простое число, непростое, 1 (граничный случай), 0 или отрицательное (возможно, определив ожидаемое поведение), большое простое число и так далее. Если код проходит все эти тесты, он, скорее всего, корректен.

Ты даже можешь попросить AI сгенерировать эти тесты:

Напиши юнит-тесты на PyTest для функции выше, покрывая граничные случаи.

Он часто справляется неплохо. Тем не менее, проверь их, чтобы убедиться, что они валидны и покрывают то, что ты считаешь необходимым.
## Интеграционные тесты
Если код AI взаимодействует с другими частями кодовой базы, например, с функцией, использующей базу данных, напиши тест, который вызывает его в контексте. Реально ли он сохраняет в базу то, что должен? Если он производит вывод, потребляемый другой функцией, свяжи их в тесте.
## E2E тесты (End-to-end)
Если этот код — часть большого воркфлоу, прогони сценарий от начала до конца. Например, если код AI был частью веб-роута, сделай тестовый запрос к этому роуту в тестовом окружении и посмотри, выдерживают ли проверку формат, обработка ошибок и всё остальное.

Уровень тестирования, который тебе нужен, зависит от того, насколько критичен и сложен код. Но даже быстрый ручной прогон или простые `assert`-ы в скрипте лучше, чем ничего для верификации. Помни, тестирование не просто находит баги; оно фиксирует поведение гвоздями. Если ты изменишь что-то позже (или это сделает AI), тестирование поможет убедиться, что функциональность кода не деградировала.

Тестирование — это также хороший способ заявить права на владение (ownership). Как только ты протестировал и исправил все проблемы, ты можешь быть уверен в коде. В этот момент справедливо сказать, что код «твой», так же как и любой другой код в проекте. Ты его понимаешь, ты ему доверяешь, и у тебя есть тесты, чтобы его охранять.
## Заметка про AI и тестирование
Some AI coding tools начинают интегрировать предложения по тестированию. Например, CodeWhisperer иногда предлагает `assert` после куска кода. Используй эти предложения как отправную точку, но не думай, что они на 100% исчерпывающие. Думай о креативных граничных случаях — это то место, где человеческая интуиция всё еще очень ценна.
## Итоги и следующие шаги
Мы прошли полный цикл: генерация, осмысление, отладка и рефакторинг. Этот луп может пролететь за считанные минуты (если функция мелкая) или растянуться на часы и дни (для жирных модулей, где ИИ подключается набегами).

Важно зарубить себе на носу: **за итоговый код отвечаешь ты, девелопер**. ИИ — это просто инструмент, чтобы ты кодил быстрее, но он не возьмет вину на себя, если на проде всё накроется медным тазом. Тут есть и риски по лицензиям и авторским правам: некоторые провайдеры ИИ честно предупреждают, что длинные куски кода могут статистически совпадать с чьим-то копирайтом. Это случается редко, и провайдеры сильно пофиксили эту проблему, но, как ты сканируешь ответы со Stack Overflow на предмет чужих лицензий, так же делай быстрый чек и тут — особенно если выхлоп большой или подозрительно чистый.

Например, если ты пишешь промт "реализуй quicksort" и нейронка выдает тебе 20 строк стерильного кода — это, скорее всего, ок, это "общее знание". Но если ты просишь какую-то мутную специфику и получаешь огромный кусок кода — не поленись, выдерни уникальную строку и пробей её в поисковике. Не выдрано ли это откуда-то под копирку? Эта проблема всплыла недавно, когда ИИ спалили на воспроизведении текста из научных статей и других защищенных источников. Часть твоего ответственного владения кодом — проверять, откуда растут ноги у любого сгенерированного контента, который выглядит сложнее шаблонных паттернов или кажется слишком уж специфичным.

И наконец, интегрируй этот код в проект: закинь в систему контроля версий (VCS), может, даже черкани в коммит-месседже, что тут помогал ИИ. Никто не заставляет, но некоторые команды любят вести такую статистику.

Со временем требования поменяются, и тебе придется этот код править. Относись к нему как к любому другому коду: не надо думать "Ой, это код робота, попрошу-ка я робота его пофиксить". Хочешь — проси, но можешь спокойно переписать всё руками. Делай так, как быстрее и проще поддерживать.

После тщательного код-ревью и тестов сгенерированный код становится просто *ещё одним куском кода* в твоем проекте. В этот момент абсолютно фиолетово, кто написал 10-ю строчку — ты или алгоритм. Главное, что она работает и соответствует стандартам проекта.

Следуя этим практикам, ты оседлаешь скорость ИИ-кодинга, не жертвуя качеством. Ты избегаешь ловушки слепой веры в "магию" и вместо этого встраиваешь её в профессиональный рабочий процесс.

Дальше, **Глава 6** рассмотрит, как ИИ-инструменты могут фундаментально перевернуть фазу прототипирования. Я расскажу про практические техники, как запрячь ИИ-ассистентов, чтобы пролететь путь от "есть идейка" до "рабочий прототип" за часы, а не за дни. Обсудим конкретные тулзы для прототипирования, включая Vercel v0 и утилиты типа "из скриншота в код", а также стратегии итеративной допилки под присмотром ИИ.

Я также разберу тот самый критический момент перехода от "слепленного нейронкой прототипа" к коду, готовому для продакшена. Посмотрим и на возможности, и на грабли, на которые можно наступить, когда ИИ становится ядром твоего воркфлоу. На реальных кейсах я покажу, как разрабы успешно юзают ИИ для быстрого теста гипотез, сохраняя при этом качество кода — и как не облажаться, пытаясь слишком быстро перепрыгнуть от концепта к реализации.
