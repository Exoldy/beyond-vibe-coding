# Глава 7. Строим веб-приложения с ИИ

В этой главе мы смещаем фокус с клепания быстрых прототипов на разработку полноценных веб-приложений с помощью ИИ. Веб-аппы обычно состоят из фронтенда (чаще всего на React, Angular или Vue), бэкенда (API, базы данных, сервера) и "клея", который всё это держит вместе. Вайб-кодинг может ускорить работу на каждом из этих слоев.

Я проведу тебя через полный цикл создания веб-приложения с ИИ-напарником, включая:
## Настройку проекта и скаффолдинг (создание скелета)
## Кодинг UI фронтенда
## Реализацию логики бэкенда
## Интеграцию с базой данных
## Тестирование и валидацию всего стека

По ходу дела я подсвечу паттерны разработки с ИИ для фронта (например, генерация компонентов React или Vue по описанию) и бэка (написание роутов, бизнес-логики и запросов к БД через промты на естественном языке). Также расскажу, как оптимизировать коллаборацию между кожаным мешком и машиной в фуллстек-проекте, чтобы каждый делал то, что умеет лучше всего. К концу главы у тебя будет четкая дорожная карта: как юзать ИИ не просто для точечных задач, а для эффективного руления всем процессом веб-разработки.

## Настройка проекта: Скаффолдинг с ИИ
Любое веб-приложение начинается со скаффолдинга — первичной настройки сборщиков, структуры файлов, зависимостей и прочей мути. ИИ может автоматизировать создание кучи этого бойлерплейта. Современные фреймворки часто идут с CLI-тулзами, которые генерируют базу, но тебе всё равно придется настраивать конфиги или прикручивать лишние либы. ИИ-ассистент поможет либо продраться через эти CLI, либо настроит кастомную структуру по запросу.

Допустим, ты хочешь запустить новый проект: React на фронте, Express на бэке. Раньше (в до-ИИ эпоху) рабочий процесс выглядел бы примерно так:

Запустил CLI или Vite для настройки React-проекта.

Инициализировал Express-приложение (через `npm init` и установку Express).

Настроил прокси для dev-режима или CORS, чтобы React-фронт мог нормально "базарить" с Express-бэком.

Возможно, прикрутил базу типа MongoDB или создал файл SQLite для простоты.

Используя ИИ-среду типа Cursor или Cline, ты можешь просто описать хотелку за один заход:

> Настрой новый проект с React-фронтендом (используй Vite) и Express-бэкендом. Бэк должен отдавать REST API для ту-ду листа и использовать массив в памяти для старта. Настрой фронтенд так, чтобы он проксировал API-запросы на бэкенд в режиме разработки.

Продвинутая ИИ-IDE возьмет эту инструкцию и сделает следующее:

Создаст две директории (`frontend` и `backend`).

Запустит `npm create vite@latest` (если у неё есть доступ к шеллу) или накидает шаблон базового React-приложения.

Инициализирует базовый файл сервера Express на бэке с эндпоинтом типа `/api/to-dos` (возвращающим какие-нибудь тестовые данные).

Закинет `package.json` в каждую папку с нужными скриптами (типа "запустить всё сразу").

Настроит связь между фронтом и бэком: либо через конфиг прокси в dev-сервере React, либо выдав инструкции по настройке заголовков CORS.

Через пару минут у тебя будет скелет фуллстек-приложения. Даже если ИИ не сделает всё на полном автомате, он вывалит код и инструкции, как допилить (например: "Добавь эту настройку прокси в свой `package.json`"). Это экономит кучу времени на тупую настройку и позволяет сразу сфокусироваться на фичах.

Если ты не юзаешь ИИ-IDE, можно использовать ChatGPT или другого ассистента пошагово:

> Я хочу создать новое React-приложение. Какие команды мне запустить?

ИИ проведет тебя по шагам или порекомендует современные альтернативы типа Vite или Next.js:

> Теперь настрой сервер Express с роутом `/api/to-dos`.

Он сгенерит код для сервера Express, который ты просто копипастишь в файл:

> Как мне соединить мое React-приложение с этим API во время разработки?

Он предложит либо настройку прокси, либо расскажет, как вызывать API (включая полный URL, если без прокси).

Таким образом, даже настройка базовой "сантехники" превращается в диалог, а не в рысканье по документации. Как уже говорилось в прошлых главах, программирование намерениями (programming by intent) означает, что ты говоришь ИИ, какой результат нужен, а он разбирается с шагами. Настройка проекта — идеальный сценарий для этого.

На этом этапе важно **продавить свои архитектурные решения**. ИИ пойдет за тобой. Люди всё ещё незаменимы для архитектуры и высокоуровневых решений, так что выбирай стек и основные паттерны сам: хочешь монорепозиторий или разные репы для фронта и бэка? Будешь юзать REST или GraphQL? Какую базу данных?

Как только определишься, давай инструкции ИИ:

> Также настрой базовую схему Prisma для базы данных SQLite.

Или:

> Включи GraphQL сервер вместо REST.

Нейронка может и не вывезет сложные сетапы идеально с первого раза, но большую часть грязной работы сделает, а ты уже дошлифуешь.

Многие опытные сеньоры запихивают эти шаги в шаблоны проектов или генераторы бойлерплейта, но ИИ дает гибкость: ты можешь кастомизировать всё на лету обычным языком. Если твой проект немного нестандартный (скажем, тебе нужно три сервиса вместо обычных двух, или ты хочешь преднастроить конкретную либу типа Tailwind CSS), просто попроси ИИ добавить это.

## Паттерны разработки фронтенда с ИИ
Как только скелет готов, начинается основная возня — разработка фронтенда. В этом разделе посмотрим, как запрячь ИИ-напарника писать фронтенд-код.

## Реализация компонентов по описанию
Ты можешь просить ИИ создавать компоненты, просто описывая их функционал и внешний вид. Например:

> Создай React-компонент `TodoList`, который принимает список задач и отображает их. У каждого айтема должен быть заголовок и чекбокс, чтобы отметить его как выполненный.

ИИ выдаст код функционального компонента с пропами и стейтом, как положено:

> Создай Vue-компонент для формы логина с инпутами для юзернейма и пароля, и чтобы он эмитил событие с данными формы при сабмите.

ИИ выплюнет секции `<template>`, `<script>` и `<style>`. Ты, как разработчик, скипаешь написание скучного бойлерплейта и сразу получаешь нужную структуру. Её легко подправить, если что. Часто ИИ даже добавит базовую валидацию или обработку стейта, если твой промт на это намекает.

Важно следить за **консистентностью** на этом этапе. Если ты генеришь кучу компонентов по отдельности, возможно, придется подгонять их друг к другу. Например, если `TodoList` ждет данные в определенном формате, убедись, что компонент, который использует `TodoList`, передает именно этот формат. Можно генерить компоненты одним промтом (чтобы ИИ видел всю картину) или просто соединять их самому и просить ИИ пофиксить нестыковки.

## Стилизация и верстка
CSS и стилизация — это часто душнилово. Опиши желаемый вид, и пусть ИИ парится с деталями CSS:

> Стилизуй компонент списка задач: используй флекс-колонку, добавь отступы, сделай текст выполненных задач серым и зачеркнутым.

> Для формы логина: отцентруй её на странице и сделай поля ввода побольше с скругленными границами.

Ассистент может выдать CSS-in-JS, обычный CSS или инлайн-стили, в зависимости от контекста. Если юзаешь фреймворк типа Tailwind CSS, можешь попросить выдать соответствующие классы (но помни, что не все модели знают Tailwind досконально).

Суть в том, что ты можешь итерировать дизайн, не ковыряясь вручную в значениях CSS. Это держит твой фокус на более высоком уровне абстракции — ты говоришь "сделай красиво", а не пишешь каждый марджин и цвет руками.

## Интеграция API и стейт-менеджмент
Веб-фронтенды постоянно тянут данные с бэка и рулят стейтом через Redux, Context или просто стейт компонента. ИИ поможет написать эти куски интеграции:

> Добавь код для фетча списка задач с `/api/to-dos` при маунте компонента `TodoList` и сохрани его в стейт.

> Реализуй функцию в `TodoList`, которая при переключении чекбокса шлет POST-запрос на `/api/to-dos/{id}/complete`, а затем обновляет стейт.

ИИ сгенерит хук `useEffect` в React для фетча или `mounted()` в Vue. Он также накидает заглушки для HTTP-вызовов (используя `fetch` или `Axios`). Тебе нужно будет подтвердить, что эндпоинты и пейлоады совпадают с тем, что ждет твой бэкенд (если ты его уже построил или у тебя есть спека).

Если бэка еще нет, ты можешь пилить его параллельно с помощью того же ИИ — до этого мы скоро доберемся. Фронт и бэк можно разрабатывать параллельно с ИИ, так как каждый слой можно специфицировать и генерить относительно независимо, главное — следить за интерфейсом между ними.

## Разруливание сложности с помощью ИИ
Если на фронте есть сложная логика, типа динамической валидации форм, условного рендеринга или хитрых взаимодействий с юзером, реализуй это пошагово с ИИ. Хорошая практика — декомпозировать проблему:

> Добавь фичу: когда юзер чекает бокс "выполнено", элемент списка должен плавно исчезнуть (CSS transition), а затем удалиться из списка через 1 секунду.

ИИ может выдать код, который вешает CSS-класс при клике и использует таймаут для удаления элемента, включая нужный CSS для анимации исчезновения:

> В форме есть опциональное поле 'notes'. Показывай текстовое поле для заметок только если чекбокс 'Add notes' нажат.

ИИ поправит стейт компонента и JSX, чтобы рендерить поле заметок по условию.

Каждый такой шаг может быть итеративным промтом. По сути, ты описываешь UX-поведение, а ИИ пишет код. Всегда тестируй после каждого добавления, чтобы убедиться, что оно работает как надо.

## Советы по фреймворкам
У разных фреймворков свои приколы:

В **React** ИИ будет использовать хуки (типа `useState`, `useEffect`). Дважды проверь, что он следует бест-практис (например, что массив зависимостей в `useEffect` правильный).

В **Vue** ИИ может выдать стиль Options API или Composition API, в зависимости от того, на чем он обучался или что увидел в контексте. Если тебе принципиально, укажи это (например: "Используй Vue 3 Composition API").

В **Angular** кривая обучения покруче. ИИ может сгенерить шаблон, класс TypeScript и базовую инъекцию сервисов по запросу, но тебе, скорее всего, придется больше работать руками или юзать Angular CLI для структуры, а потом просить ИИ заполнить конкретные части (типа логики валидации форм).

## Паттерны разработки Бэкенда/API с ИИ
Теперь развернемся к бэкенду. Использование ИИ для серверной части следует тому же принципу: ты описываешь эндпоинты, модели данных и логику, а ИИ выдает код. Типичные компоненты бэка — это обработчики роутов, бизнес-логика, работа с БД и валидации. ИИ поможет со всем этим.

## Реализация эндпоинтов API
Допустим, ты пилишь RESTful API для своего ту-ду листа. У тебя могут быть эндпоинты типа `GET /to-dos`, `POST /to-dos`, `PUT /to-dos/:id`, `DELETE /to-dos/:id`. Можно идти по одному эндпоинту за раз:

> В приложении Express добавь роут `GET /api/to-dos`, который возвращает список задач (пока используй просто массив в памяти).

> Добавь роут `POST /api/to-dos`, который принимает JSON-тело и добавляет новую задачу в список. Верни новую задачу с ID.

ИИ напишет обработчики роутов Express, скорее всего, используя что-то вроде `app.get('/api/to-dos', ...)`. Если ты указал, что юзаешь Express с JSON, он может добавить нужный мидлвар, если его еще нет:

`app.use(express.json())`

Когда бэк разрастется, можешь попросить ИИ сделать рефакторинг:

> Отрифактори роуты Express в отдельный модуль роутера.

Он вынесет роуты в отдельный файл, что есть гуд для поддерживаемости кода.

## Интеграция с базой данных
Для прототипа сойдет и память, но для серьезного приложения нужна нормальная база. Скажем, ты выбрал MongoDB или PostgreSQL. Промпт может быть таким:

> Интегрируй MongoDB в приложение Express используя Mongoose. Создай модель `Todo` с полями: `title` (string), `completed` (boolean). Измени роуты GET/POST, чтобы они использовали базу данных вместо массива в памяти.

ИИ выдаст определение модели Mongoose и поправит хендлеры роутов, чтобы они дергали базу (типа `Todo.find()` для GET и `Todo.create()` для POST). Аналогично для SQL, ты можешь попросить настроить ORM типа Prisma или Sequelize. Имей в виду, тебе, возможно, придется предоставить конфиги (типа строки подключения). ИИ может не знать твой URI базы данных, так что подставишь его сам. Но весь дженерик-код он напишет.

## Бизнес-логика и валидация
Если на бэке есть специфические правила (например, юзеры не могут удалять "важные" задачи или заголовки должны быть уникальными), ты можешь зашить это через ИИ:

> Добавь валидацию в роут `POST /api/to-dos`: отбивай запрос с 400 статусом, если заголовок пустой или длиннее 100 символов.

ИИ добавит проверки и отправку правильных ответов.

> Добавь логику: когда задача отмечается выполненной (скажем, через `PUT /api/to-dos/:id`), если все задачи выполнены, пиши в лог сообщение 'All done!'

Он вставит эту логику в PUT-хендлер.

Ты описываешь требования простым языком, а ИИ меняет код. Тебе всё равно нужно тестировать, чтобы код делал именно то, что ты ожидаешь.

## Использование фреймворков и бойлерплейтов
Многие бэкенды используют фреймворки покруче "голого" Express (типа NestJS для Node или Django для Python). ИИ умеет работать и с ними, хотя задачи придется дробить сильнее:

Для **Django** (Python) можно попросить:

> Создай модель Django для todo с полями X, и соответствующие view для списка и создания.

ИИ может выдать код модели и дженерик view или сериализатор/viewset для DRF (Django REST Framework), если он знает контекст.

Для **Ruby on Rails** можно получить помощь в генерации моделей и контроллеров. (Тут ты, скорее всего, просто заюзаешь скаффолдинг Rails, но ИИ может помочь, добавив валидации или подправив роуты).

ИИ-модели показывают разный уровень скилла в разных языках и стеках, в основном из-за того, насколько часто эти технологии встречались в обучающей выборке. Модели могут работать с любым языком, который видели, но эффективность скачет. Популярные языки типа JavaScript, Python и Java обычно поддерживаются лучше всего из-за тонн кода в опенсорсе, документации и учебных материалов.

Определить, насколько модель шарит в твоем стеке, можно только на практике. Начни с базовых задач на нужном языке, потом усложняй. Смотри, генерит ли модель идиоматичный код (согласно конвенциям языка), узнает ли популярные фреймворки без долгих объяснений и предлагает ли подходящие паттерны. Если шарит — предложит что-то дельное по контексту; если нет — будет выдавать дженерик или устаревший код.

Многие провайдеры ИИ публикуют доки о возможностях моделей, но там редко бывают детальные бенчмарки по языкам. Самый надежный способ — провести небольшие эксперименты с твоим реальным стеком. Например, если ты на Ruby on Rails, проверь, понимает ли модель конвенции ActiveRecord или может ли сгенерить нормальные тесты на RSpec. Для новых фреймворков или редких языков будь готов к тому, что результаты будут плавать, и придется давать больше контекста в промтах, чтобы компенсировать пробелы в знаниях модели.

## Оркестрация многоходовок
Некоторые эндпоинты могут включать несколько шагов, типа создания записи в одной таблице, потом в другой, или вызова внешнего API. Ты можешь накидать последовательность, а ИИ оформит это в код:

> Когда новый юзер регистрируется (`POST /api/users`), создай запись юзера и также отправь приветственное письмо через SendGrid API.

ИИ напишет код для сохранения юзера (возможно, через ORM) и затем HTTP-запрос к API SendGrid с нужным пейлоадом. Тебе останется вставить реальные API-ключи или подправить контент, но основной бойлерплейт готов.

> Реализуй транзакцию: при переводе денег (`POST /api/transfer`) сними со счета А и добавь на счет Б, убедись, что это атомарно (всё или ничего).

Если ты используешь ORM или БД с поддержкой транзакций, ИИ может заюзать эти фичи (типа блока транзакции в SQL или метода транзакции в ORM). Проверяй такой код с осторожностью — логика транзакций, особенно, штука хитрая. Но ИИ может знать типичные подводные камни и включить проверки. Например, получив промт на обработку перевода денег, ИИ сгенерировал вот такую структуру:

```javascript
async function transferMoney(fromAccountId, toAccountId, amount) {
  const session = await db.startSession();
  
  try {
    await session.startTransaction();
    
    // Снимаем с исходного счета
    const sourceAccount = await Account.findByIdAndUpdate(
      fromAccountId,
      { $inc: { balance: -amount } },
      { session, new: true }
    );
    
    if (sourceAccount.balance < 0) {
      throw new Error('Insufficient funds'); // Недостаточно средств
    }
    
    // Добавляем на счет назначения
    await Account.findByIdAndUpdate(
      toAccountId,
      { $inc: { balance: amount } },
      { session }
    );
    
    await session.commitTransaction();
    return { success: true };

  } catch (error) {
    await session.abortTransaction();
    throw error;
  } finally {
    session.endSession();
  }
}
```

ИИ правильно обернул обе операции с базой в транзакцию, включил валидацию на недостаточность средств и корректно обработал откат (rollback) при любой ошибке. Хотя тебе всё равно нужно будет проверить эдж-кейсы (граничные случаи) и добавить нормальное логирование, фундаментальная структура транзакции показывает понимание атомарных операций.

## Документация API и тестирование
Когда пилишь API, можно заодно заставить ИИ писать документацию. Например: "Напиши краткую доку для эндпоинтов `/api/to-dos`". Он может выдать что-то типа:

`GET /api/to-dos` - возвращает список задач.
`POST /api/to-dos` - создает новую задачу. Ожидает JSON: `{title: string}`. Возвращает созданную задачу.
...

Это удобно для быстрой справки и чтобы кинуть фронтендерам (если работаешь в команде). Кроме того, можно юзать ИИ для написания тестов API, используя фреймворки типа Jest или Mocha для Node, или PyTest для Python. С промтом типа "Сгенери тесты для API задач (один тест на листинг, один на создание, один на ошибку валидации)", ИИ выдаст код тестов, который можно запустить и проверить, всё ли ок.
## Проектирование базы данных и интеграция
Твоё понимание бизнеса и предметной области — это база, но AI может помочь перегнать эту базу в код (скрипты миграции или ORM-модели). А если ты сам плаваешь в схеме данных, можно поштурмить прямо с нейронкой.

Допустим, твоя приложенька переросла обычный список дел и мутирует в полноценный таск-трекер. Тебе нужно спроектировать несколько таблиц: Проекты, Задачи, Пользователи и так далее. Ты можешь спросить: «Какие модели данных нужны для простого приложения по управлению проектами с юзерами, проектами и задачами? Пропиши связи». AI может выдать что-то в таком духе:

User (id, name, email, и т.д.)

Project (id, name, owner_id со ссылкой на User)

Task (id, description, project_id, assigned_to (User), status, и т.д.)

Это может быть не совсем то, что ты хотел, но как «рыба» для старта пойдет. Ты подтверждаешь или допиливаешь эти идеи, а потом внедряешь.

## Использование ORM
Если ты сидишь на ORM типа Prisma, Entity Framework или SQLAlchemy, можно заставить AI генерировать классы моделей или определения схем:

Используя Sequelize (для Node), определи модели для User, Project, Task со связями: Один User имеет много Projects, Project принадлежит User; Project имеет много Tasks, Task принадлежит Project; Task может быть назначен на User (many-to-one).

AI напишет JS/TS код для определения этих моделей Sequelize и их ассоциаций, который ты просто вставишь в свой проект. Он может даже предложить внешние ключи или правила каскадного удаления, если шарит за контекст.

Если ты олдскул, не юзаешь ORM и пишешь миграции на чистом SQL, можно попросить AI набросать и их:

Напиши SQL-скрипт для создания таблиц users, projects, tasks с соответствующими внешними ключами.

На выходе получишь DDL-скрипт. Проверяешь глазами на адекватность и накатываешь.

## Запросы к базе данных
Когда дело доходит до интеграции базы в код, тебе могут понадобиться запросы посложнее тупого CRUD. Допустим, ты хочешь получить все проекты вместе с их задачами и юзером, назначенным на каждую задачу — это уже JOIN через Project, Task и User. Промпт может быть таким:

Напиши SQL-запрос для получения проектов с их задачами и именем назначенного пользователя для каждой задачи.

AI выплюнет тебе готовый SQL JOIN.

Или, если ты на ORM:

Используя Sequelize, выбери все проекты со связанными задачами и пользователем для каждой задачи.

Ожидай, что код придет с чем-то для подгрузки связанных данных, типа:

include: [Task, { model: User, as: 'assignedUser' }]

## Проверка сгенерированных AI запросов
Операции с базой требуют тщательной проверки, чтобы убедиться, что код от AI совпадает с твоей реальной схемой и не херит целостность данных. AI не телепат, он не знает твои специфические названия таблиц, полей или связей, пока ты ему прямо об этом не скажешь. Даже если у модели есть память контекста, лучше в каждом сложном промпте про базу напоминать детали схемы. Этот явный подход спасает от классической проблемы, когда AI генерит запросы с дефолтными именами типа `user_id`, а у тебя в базе `userId` или вообще `customer_ref`.

Вопросы производительности тоже требуют твоего кожаного надзора. Хотя модели понимают базовые концепции БД типа первичных ключей и джойнов, они могут не предложить оптимизации, вроде добавления индексов на часто запрашиваемые поля, и не будут думать о планах выполнения запросов. Ревьювь сгенерированные запросы на предмет эффективности, особенно те, что будут дергаться часто или на больших объемах данных.

Правила согласованности данных — еще одна зона риска, где нужна четкость. Когда реализуешь удаление, ясно определи ожидаемое каскадное поведение. Например, при удалении записи Project ты должен решить: база сама выкосит связанные Task через каскадное удаление, или твое приложение должно сначала почистить хвосты логикой. Объясни эти бизнес-правила AI максимально прозрачно:

Когда проект удаляется, настрой базу данных на каскадное удаление всех связанных задач.

Или наоборот:

При удалении проекта сначала проверь наличие задач и запрети удаление, если они есть.

AI может эффективно реализовать любой подход, если дать ему четкое ТЗ. Для каскадов он может сгенерить ограничения внешнего ключа с `ON DELETE CASCADE`. Для обработки на уровне приложения — код, который проверяет наличие связанных записей перед удалением. Ключ к успеху — явно проговаривать требования к целостности данных, а не надеяться, что AI сам догадается, как принято в твоем домене.

## Full Stack интеграция: Женим Фронт с Бэком
Теперь, когда ты с помощью AI собрал и фронтенд, и бэкенд, следующий челлендж — сшить их в бесшовное веб-приложение. Нужно убедиться, что эндпоинты API дергаются с фронта правильно, данные текут куда надо, и система в целом не разваливается.

## Выравнивание контрактов Фронтенда и Бэкенда
Это критично: фронтенд ожидает получить данные в определенной форме, поэтому то, что отправляет бэкенд, должно соответствовать этим ожиданиям. Если позволишь AI пилить каждую часть в изоляции, начнутся мелкие нестыковки (например, бэк возвращает `{ success: true, data: [...] }`, а фронт ждет массив напрямую). Чтобы избежать этого факапа, можешь явно инструктировать AI о формате ответа при кодинге обеих сторон. Либо, когда всё готово, проведи end-to-end тест: открой веб-приложение и посмотри, грузится ли список. Если нет — сверяй консоль браузера с логами сервера.

Я часто использую AI, чтобы подогнать одну сторону под другую:

Если бэкенд возвращает JSON с ключами, которые немного отличаются от того, что ждет фронт, и ты поймал баг, скажи AI (для любой из сторон):

Измени код, чтобы использовать ‘tasks’ (множественное число) вместо ‘taskList’ (единственное) в JSON.

Если фронт шлет данные формы как `form-encoded`, а бэк ждет JSON, попроси AI конвертировать это — например, через `JSON.stringify` на фронте или добавив `body-parser` на бэке.

## Коллаборация с AI в реальном времени
IDE с поддержкой AI, которые держат контекст всего проекта (типа Cline или Cursor), особенно полезны на этапе интеграции. Ты можешь открыть файлы фронта и бэка рядом в редакторе и запромптить:

Убедись, что фетч на фронтенде из /api/to-dos совпадает с ожидаемым запросом/ответом в маршруте Express. Исправь любые расхождения.

AI синхронизирует контент (например, добавит `await response.json()` на фронте, если его не было, или поправит структуру JSON).

## Управление состоянием и синхронизация
В фуллстек-приложении, чтобы результат выглядел профессионально, не забудь про состояния загрузки и обработку ошибок на фронте при фейлах API. Используй промпты вроде:

Добавь индикаторы загрузки: когда React-компонент фечит задачи, показывай текст ‘Загрузка...’, пока данные не придут.

Или:

Обработай ошибки: если вызов API падает (ответ не 200), покажи сообщение об ошибке в UI.

Он добавит стейт `isLoading` и условный рендеринг, или обернет фетч в `try/catch`, чтобы поймать ошибки и вывести месседж. Такой лоск делает твое приложение надежным и приятным в использовании.

## WebSockets и продвинутые интеграции
Если твоему приложению нужен реалтайм (через WebSockets или SSE), промпт может выглядеть так:

Настрой WebSocket с использованием Socket.io. Когда на сервере создается новая задача, транслируй её всем подключенным клиентам. Модифицируй фронтенд, чтобы он слушал новые задачи и добавлял их в список в реальном времени.

Это сложно, но AI может сгенерить настройку Socket.io на сервере (типа добавления `io.on('connection', ...)` и эмита события при создании задачи), а также клиентский код для подключения и прослушивания. Интегрировать это придется аккуратно, но сам факт, что описание задачи превращается в рабочий реалтайм-код — это просто отвал башки. Если с первого раза не взлетит идеально — итеративные промпты и тесты допинают его до результата.

## Пример: Full Stack поток с AI
Для иллюстрации, представим, что ты пилишь простой веб-менеджер контактов:

Ты скаффолдишь React-фронтенд и Node/Express-бэкенд, как делал ранее.

Сначала для фронта просишь компоненты `ContactList` и `ContactForm`. Затем просишь добавить вызовы API:

В ContactList запрашивай контакты с /api/contacts при маунте.

В ContactForm при сабмите отправляй POST на /api/contacts с данными формы, затем обновляй список контактов при успехе.

Для бэкенда можешь сначала использовать массив в памяти или сразу прикрутить базу. Потом просишь роуты Express: `GET /api/contacts` (вернуть список) и `POST /api/contacts` (добавить контакт в базу или память).

Попробуй добавить контакт через UI. Если появился в списке — красавчик. Если нет — дебажь. Может, POST-роут не вернул новый контакт правильно, или код формы не обновил список. Найди дыру и попроси AI пофиксить:

После добавления контакта бэкенд должен возвращать объект нового контакта в ответе, а фронтенд должен добавлять его в список без полной перезагрузки страницы.

Это приведет к тому, что AI поправит ответ бэка и логику стейта на фронте, чтобы пушить новый контакт (возможно, через апдейт React-стейта).

Реализуй функции редактирования и удаления аналогично, каждый раз отдавая AI рутину и фокусируя свой ввод на том, что фича *должна делать*.

Вручную на это легко ушла бы неделя-две работы джуна, но с AI-кодевелопером можно управиться за день-два, учитывая, что куча шаблонного кода и "проводов" автоматизирована.

## Оптимизация сотрудничества человека и AI в фуллстек-разработке
Когда работаешь над всем стеком, полезно поймать продуктивный ритм с твоим AI-ассистентом. Вот стратегии для оптимизации:

**Используй AI для бойлерплейта; кастомную логику пиши сам**
Определи, какие части кода — скучная рутина, а какие — уникальное ядро. Пусть AI генерит CRUD API или стандартные компоненты. Но если есть хитрая логика, проприетарный алгоритм или специфическое бизнес-правило, которое проще реализовать самому — пиши руками, а потом проси AI проверить или протестировать. Думай об этом как о делегировании: AI тащит повторяющиеся задачи, ты занимаешься новыми.

## Используй AI, чтобы разгребать бэклог по одной задаче за раз
В процессе разработки веди список задач (фичи, баги). Потом объясняй каждую задачу AI, по одной, и давай ему предлагать решение. Например, у тебя записано: «Реализовать хеширование паролей при регистрации». Попробуй такой промпт:

Добавь хеширование паролей через bcrypt в роуте POST /api/register перед сохранением пользователя.

Такой прицельный, систематический подход гарантирует, что ты ничего не забудешь.

## Промпти AI улучшать качество кода по ходу дела
Когда функционал готов, можно попросить: «Отрефактори этот код для лучшей читаемости» или «Оптимизируй эту функцию». AI часто может сделать код чище или предложить улучшения производительности, как ассистент, делающий второй проход для лоска под твоим присмотром. Только убедись, что изменения всё ещё проходят твои тесты.

## Используй AI для перекрестной проверки
Если сомневаешься в архитектурном решении, спроси AI:

Нормально ли использовать массив для хранения контактов в памяти или стоит взять базу данных? Каковы плюсы и минусы?

Хотя ты наверняка знаешь ответ (юзай базу для персистентности), это как перетереть с коллегой. Иногда AI может подкинуть соображение, о котором ты не подумал:

Если будет несколько инстансов сервера, хранилище в памяти не будет синхронизироваться между ними.

## Используй AI для координации с командой
Если работаешь в команде, не все могут использовать AI напрямую. В таком случае проси AI документировать то, что ты сделал. Также полезно сообщать команде о своем подходе: «Я использовал AI, чтобы быстро накидать эти контроллеры. Я их проверил, но поглядывайте на предмет нестандартных паттернов». Поощряй культуру код-ревью, где все проверяют написанный AI код так же, как и любой другой, чтобы отловить любые странности.

Реальные команды, внедряющие AI (как в Snyk), сообщают о росте продуктивности, но подчеркивают необходимость валидации человеком. В опросе GitHub 2024 года 97% разработчиков сообщили, что используют инструменты AI-кодинга в работе в том или ином виде.

## Тестирование и Валидация Веб-приложений, созданных AI
После сборки веб-приложения с помощью AI тестируй тщательно, чтобы убедиться, что всё работает как задумано, и отловить косяки, которые могли внести ты или AI. Вот как можно подойти к тестированию в контексте AI-ассистентов:

## Юнит-тесты
Для бэкенд-логики пиши юнит-тесты на критические функции (расчеты, валидация ввода). Если функцию писал AI, написание теста для неё может вскрыть скрытые баги. Можно даже заставить AI сгенерировать эти тесты. Но будь осторожен: тесты от AI иногда бывают тривиальными или подгоняются под реализацию, так что направляй его на проверку эдж-кейсов:

Напиши тесты для функции проверки сложности пароля, включая эдж-кейсы: пустой пароль, очень длинный пароль, пароль со спецсимволами и т.д.

## Интеграционные тесты
Проверь эндпоинты API чем-то вроде Supertest (для Node) или прямыми HTTP-вызовами. Убедись, что каждый эндпоинт возвращает ожидаемое. AI поможет набросать скелет:

Напиши интеграционные тесты для эндпоинтов /api/to-dos используя Jest и Supertest.

Он выдаст тесты, которые запускают приложение, долбятся в эндпоинты и проверяют ответы.

## Фронтенд-тесты
Тестирование веб-интерфейса можно делать инструментами типа Jest (для логики компонентов) и Cypress или Playwright для end-to-end тестов UI. Ты вполне можешь попросить AI сгенерировать сценарий теста Cypress:

Напиши тест Cypress, который загружает приложение, добавляет новую задачу через форму и проверяет, что она появилась в списке.

Получишь скрипт теста, который можно запускать. Это мощная штука — ты быстро получаешь покрытие end-to-end тестами, используя AI для скриптования пользовательских действий.

## Ручное тестирование
Какие бы автотесты ты ни гонял, всегда делай ручное исследовательское тестирование. Потыкай приложение сам (или отдай QA, если ты в команде). AI может не предусмотреть каждый сценарий реального мира: например, кнопка "Назад" в браузере ломает какой-то стейт, или определенная последовательность действий вызывает глюк. Находишь баги — фикси сам или проси AI помочь. Ручное тестирование также важно для оценки UI/UX — приятно ли пользоваться приложением? Нет ли кривых флоу? AI не умеет оценивать эти субъективные UX-моменты, тут нужен фидбек от человека.

## Код-ревью
Если работаешь с другими, пусть они ревьювят код от AI. Свежий взгляд поймает то, что ты мог пропустить — дыру в безопасности или просто подскажет более идиоматичный способ написания. Команды с AI часто сохраняют обычные процессы ревью, просто с большим фокусом на поиск тонких багов или проблем безопасности, которые AI мог случайно внести.

## Аудит безопасности
Глава 8 углубится в безопасность, но даже на этапе разработки стоит сканить код на известные паттерны уязвимостей. Есть автоматические тулзы (линтеры, SAST), или можно запромптить AI:

Проверь код Express-приложения и перечисли потенциальные уязвимости безопасности или нарушения лучших практик.

AI может подсветить удивительные вещи, типа «Ты тут не санитайзишь пользовательский ввод» или «Тебе стоит нормально настроить CORS». Используй это как чек-лист для "закаливания" приложения.

Интересный побочный эффект использования AI: ты можешь начать писать тесты, которые раньше бы не писал, просто потому что AI делает их создание элементарным. Это реально ведет к более надежному коду в итоге. Если возьмешь за правило генерить тесты сразу после фич (по сути, AI-assisted TDD или хотя бы тесты постфактум), ты гарантируешь, что быстрая разработка не убьет качество. Думай об этом так: раз AI сэкономил тебе время на написании кода, инвестируй часть этого времени в написание и прогон тестов.

AI может предложить небезопасный код, если юзер не бдит. Например, ранние версии AI могли генерить SQL-запросы, уязвимые к инъекциям, если их специально не просили этого избежать. Тестируя и ревьювя, ты ловишь эти проблемы. Одно исследование показало, что разрабы с AI-ассистентами склонны быть самоуверенными насчет безопасности своего кода, даже когда он хуже написанного вручную.

Никогда не забивай на валидацию только потому, что код написал AI. Считай, что там могут быть баги, как и в любом коде, написанном человеком.

## Примеры успешных веб-проектов, созданных с AI
Давай подсветим пару примеров (сборные образы из разных отчетов), где помощь AI сыграла ключевую роль в релизе реальных веб-приложений.

## E-commerce сайт от соло-разработчика
Один соло-разраб хотел запилить небольшой магазин для продажи кастомных футболок, но был ограничен во времени. Он использовал GPT через расширение в IDE, чтобы построить весь стек. Он промптил AI генерировать React-фронтенд со списком товаров, корзиной и страницами чекаута, а также Node.js бэкенд с эндпоинтами для продуктов и заказов. Для платежей взял Stripe, интегрировав его с помощью подсказок AI по Stripe API. Поработав вечерами две недели, он получил рабочий сайт.

Этот разраб сообщил, что AI сделал, наверное, 70% кодинга, особенно повторяющиеся части UI и обработку форм, пока он сам фокусировался на правильной настройке Stripe и доводке UI под бренд. В итоге клиенты могли смотреть товары, кидать в корзину и покупать — и всё это в системе, построенной по большей части через вайб-кодинг. Это также показывает, что интеграция внешних сервисов (как Stripe) вполне реальна с руководством AI, если доступна документация или ты скармливаешь её модели.

## Внутренний дашборд компании
Продакт-менеджер с навыками кодинга использовала AI-парного программиста для создания внутреннего аналитического дашборда для своей команды. Обычно ей пришлось бы ждать ресурсы инженеров, но с инструментом типа Ghostwriter от Replit или GitHub Copilot она смогла собрать базовое веб-приложение сама. AI помог настроить простой бэкенд на Flask для запросов к базе (с безопасными правами только на чтение) и фронтенд на Vue.js для отображения графиков (используя библиотеку чартов). Она описывала, что должен показывать каждый график («всего регистраций по времени», «активные юзеры по регионам»), а AI писал SQL-запросы и код графиков.

Весь процесс занял пару недель ковыряния и тестов, но в итоге она выкатила рабочий дашборд. Качество кода было не энтерпрайз-уровня, но для внутреннего пользования — сойдет. Что важнее, она дала команде инструмент за долю времени. Этот пример иллюстрирует, как AI-тулзы позволяют неспециалистам пилить полезные веб-приложения, разблокируя задачи, которые иначе пылились бы в бэклоге. Это пример «разбандлинга программиста» (unbundling of the programmer), о котором я расскажу в Главе 10 — о том, как люди могут создавать личный или командный софт гораздо проще.
## MVP стартапа (Минимально жизнеспособный продукт)

Один маленький стартап (всего два отца-основателя: один про бизнес, второй — технарь) нуждался в MVP веб-приложения, чтобы пустить пыль в глаза инвесторам. Технарь врубил режим вайб-кодинга на полную катушку, чтобы запилить MVP в рекордные сроки. С помощью ИИ-ассистента он накидал скелет современного веб-приложения на Next.js (для SSR React фронтенда) и простенький Node API. Он запряг ИИ пилить такие фичи, как вход через соцсети (ИИ сам написал флоу OAuth), загрузку картинок (ИИ подружился с API облачного хранилища) и даже какую-то ИИ-фичу внутри самого продукта. Они даже использовали ИИ, чтобы прикрутить NLP-модель через сторонний API. За пару месяцев один разраб сделал то, на что у небольшой команды обычно уходит от четырех до шести месяцев. Результат получился, конечно, костыльным, но рабочим — его можно было демонить и даже загонять на платформу бета-юзеров.

Когда позже фаундеры наняли еще разрабов, чтобы навести лоск на продукт, новички обнаружили, что код, написанный нейронкой, в принципе понятен, хотя им и пришлось переписать (отрефакторить) значительные куски ради масштабируемости. Это подчеркивает суть: ИИ может быстро доставить тебя на первый уровень, но чтобы двигаться дальше, придется вложиться в качество.

Эти истории, хоть и звучат как байки из курилки, вполне укладываются в новые тренды индустрии. Особенно в веб-разработке, где часто нужно просто скручивать кучу компонентов вместе, буст производительности очень ощутим. Microsoft и прочие ребята отчитываются об исследованиях, где разрабы с ИИ закрывали таски значительно быстрее тех, кто кодил по-старинке.

Однако есть и истории про эпичные провалы. Например, разраб может выкатить в прод сгенерированное ИИ приложение с дырой в безопасности просто потому, что ни хрена не понимает, что там внутри написано. Этот риск лишний раз напоминает, почему тестирование и код-ревью — это святое.

Короче говоря, создание веб-приложений с помощью ИИ становится мейнстримом. Это не отменяет нужду в скилловых разрабах, скорее наоборот — прокачивает их. Разрабы по-прежнему планируют архитектуру, следят за корректностью и разгребают сложные или нестандартные куски кода, пока ИИ берет на себя унылый бойлерплейт, который склеивает всё это воедино. Тот сквозной воркфлоу, который мы разобрали — от скаффолдинга до фронта, бэка и тестов — доказывает, что практически каждый этап веб-разработки можно ускорить с помощью ИИ, если не отключать голову и применять свой опыт.

## Итоги и следующие шаги

В этой главе вы увидели, как вайб-кодинг масштабируется до разработки полноценных веб-приложений. Относясь к ИИ как к всегда доступному напарнику, вы можете параллельно раскидывать задачи по фронтенду и бэкенду, генерить компоненты и API из обычных описаний и итеративно доводить прототип до продакшн-качества. Ключи к успеху: четко доносить свои хотелки (чтобы ИИ понимал контекст на каждом шаге), внимательно проверять результат (чтобы ловить баги в выхлопе нейронки) и юзать ИИ не только для генерации кода, но и для таких вещей, как брейншторминг схем БД и написание тестов.

Эта глава также показала, как разработчик может эффективно стать фуллстек-инженером, усиленным ИИ, который затыкает дыры в его знаниях, подсказывая код в тех областях, где он плавает. Это дико сокращает время разработки типовых фич и в каком-то смысле демократизирует процесс, позволяя людям пилить кастомные веб-решения без огромных команд (к этой теме я еще вернусь в Главе 10).

ИИ не заменяет понимание требований и контроль качества; он просто ускоряет исполнение.

Теперь, когда ваше веб-приложение запущено и шуршит вентиляторами, следующая головная боль — сделать его безопасным, надежным и поддерживаемым. Глава 8 погружает в дебри безопасности и надежности кодовых баз, сгенерированных ИИ. Мы разберем типичные уязвимости, которые могут проскользнуть незамеченными, как их аудить и фиксить, и какие лучшие практики (вроде тех, что мы уже начали применять с тестами и ревью) использовать, чтобы быстрая езда с ИИ не привела к аварии. По сути, мы перейдем от строительства к укреплению позиций — сделаем так, чтобы ваш вайб-код выдержал столкновение с суровой реальностью и угрозами.
