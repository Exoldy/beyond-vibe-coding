import{_ as i,o as a,c as t,ae as p}from"./chunks/framework.Dn7Y7LSn.js";const o=JSON.parse('{"title":"Глава 6. Прототипирование с ИИ: Инструменты и техники","description":"","frontmatter":{},"headers":[],"relativePath":"chapter_6.md","filePath":"chapter_6.md"}'),h={name:"chapter_6.md"};function l(k,s,n,e,E,r){return a(),t("div",null,[...s[0]||(s[0]=[p(`<h1 id="глава-6-прототипирование-с-ии-инструменты-и-техники" tabindex="-1">Глава 6. Прототипирование с ИИ: Инструменты и техники <a class="header-anchor" href="#глава-6-прототипирование-с-ии-инструменты-и-техники" aria-label="Permalink to &quot;Глава 6. Прототипирование с ИИ: Инструменты и техники&quot;">​</a></h1><p>В этой главе мы разберем, как вайб-кодинг на движке ИИ разгоняет фазу прототипирования разработки софта. Суть прототипирования — максимально быстро превратить идею в рабочую модель. С ИИ-ассистентами разрабы могут за часы сделать то, на что обычно уходят дни, стремительно итерируя концепции. Я расскажу о техниках перехода от &quot;хотелки&quot; к прототипу с помощью ИИ, сравню популярные инструменты (включая Vercel v0 и утилиты типа «скриншот-в-код») и покажу, как итеративно допиливать прототипы под чутким руководством нейронки. Мы также затронем критически важный этап: как превратить этот черновой, сгенерированный ИИ прототип в качественный код для продакшена. По ходу главы я буду приводить кейсы, где прототипирование с ИИ привело к успеху, и подсвечу как потенциал, так и грабли этого подхода.</p><h2 id="быстрое-прототипирование-с-ии-ассистентами" tabindex="-1">Быстрое прототипирование с ИИ-ассистентами <a class="header-anchor" href="#быстрое-прототипирование-с-ии-ассистентами" aria-label="Permalink to &quot;Быстрое прототипирование с ИИ-ассистентами&quot;">​</a></h2><p>Прототипирование выигрывает от скорости генерации кода ИИ как никто другой. Цель здесь — не вылизанный, готовый к проду код, а Proof of Concept (PoC), который можно потыкать палкой, оценить и доработать. ИИ-ассистенты здесь раскрываются во всей красе, выдавая рабочий код из минимальных вводных. Например, вместо того чтобы вручную верстать макет UI, разраб может описать желаемый интерфейс на естественном языке и позволить ИИ сгенерировать HTML/CSS или React-компоненты. Это обеспечивает дико быстрый цикл «идея — реализация».</p><p>Один UX-инженер так описывает, как генеративный ИИ перевернул его рабочий процесс: «Скорость, с которой я клепал рабочие прототипы на GenAI, просто взрывала мозг. Я собирал за пару часов прототипы, на которые обычно уходили дни». ИИ берет на себя рутинный бойлерплейт и повторяющиеся паттерны, освобождая инженера для принятия архитектурных и дизайнерских решений высокого уровня. В прототипировании это значит, что ты можешь проверить больше идей за то же время. Еще один плюс: ИИ может почти мгновенно заполнить скучные части прототипа (базовые UI-компоненты, обработку форм, тестовые данные), позволяя человеку сосредоточиться на ключевой концепции или уникальной фиче, которую нужно протестировать.</p><p>Однако, братан, важно помнить: код прототипа — это часто код на выброс. ИИ может быстро выдать рабочее решение, но этот код вряд ли будет структурирован для поддержки или масштабирования. Для прототипов это норм: здесь скорость и эксперименты важнее элегантности — при условии, что ты планируешь отрефакторить или переписать критические части для прода (об этом процессе я расскажу позже в этой главе). Как мы обсуждали в Главах 3 и 4, ИИ может уверенно взять на себя около 70% кодинга для прототипа, пока ты рулишь общей архитектурой и исправляешь критические косяки.</p><p>Здесь на сцену выходит концепция «программирования намерениями», введенная в Главе 1. Ты даешь высокоуровневые инструкции (намерение того, что прототип должен делать или как выглядеть) и позволяешь ИИ заполнить реализацию. Чтобы проиллюстрировать, давай пробежимся по очень простому примеру прототипирования с ИИ-ассистентом. Допустим, у тебя есть идея страницы регистрации для нового сервиса. Ты хочешь быстро накидать фронтенд, поэтому начинаешь со следующего промта:</p><blockquote><p>Создай простую HTML-страницу для формы регистрации с полями Имя, Email и Пароль, а также кнопкой Отправить. Сделай так, чтобы это выглядело презентабельно с базовыми стилями.</p></blockquote><p>Современный кодинг-ассистент типа Cline может выдать готовый HTML/CSS пример:</p><div class="language-html vp-adaptive-theme"><button title="Copy Code" class="copy"></button><span class="lang">html</span><pre class="shiki shiki-themes github-light github-dark vp-code" tabindex="0"><code><span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;!</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">DOCTYPE</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> lang</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;en&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> charset</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;UTF-8&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">meta</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;viewport&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> content</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;width=device-width, initial-scale=1.0&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> /&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Sign Up&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">title</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-family</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">Arial</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">sans-serif</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">max-width</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">400</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">px</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">margin</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">2</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;"> auto</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">display</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">flex-direction</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">column</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">margin-top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    input</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">, </span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">padding</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">0.5</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">font-size</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">    button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;"> { </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">margin-top</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">1</span><span style="--shiki-light:#D73A49;--shiki-dark:#F97583;">em</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">background</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">#4CAF50</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">color</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">#fff</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">border</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">: </span><span style="--shiki-light:#005CC5;--shiki-dark:#79B8FF;">none</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">; }</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">style</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">head</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Sign Up&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">h2</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Name: &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;text&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;name&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Email: &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;email&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;email&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Password: &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">input</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;password&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> name</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;password&quot;</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> required</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">label</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">    &lt;</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#6F42C1;--shiki-dark:#B392F0;"> type</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">=</span><span style="--shiki-light:#032F62;--shiki-dark:#9ECBFF;">&quot;submit&quot;</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;Create Account&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">button</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">  &lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">form</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">body</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span>
<span class="line"><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&lt;/</span><span style="--shiki-light:#22863A;--shiki-dark:#85E89D;">html</span><span style="--shiki-light:#24292E;--shiki-dark:#E1E4E8;">&gt;</span></span></code></pre></div><p>Этот сгенерированный ИИ код — вполне сносная отправная точка для прототипа формы регистрации. Тут есть базовая разметка и немного встроенного CSS для стиля. Тебе, как разрабу, не пришлось писать ни строчки HTML/CSS руками — ты просто описал результат, и ИИ выдал реализацию. Это и есть программирование намерениями: ты фокусируешься на том, <em>что</em> должен делать UI, а ИИ разбирается, <em>как</em> это сделать.</p><p>Конечно, это примитивный пример. На практике прототипы могут быть сложнее, включать кучу файлов, фреймворков или данных. Но принцип тот же: ты используешь ИИ, чтобы стремительно создать черновик. Потом ты открываешь этот прототип в браузере, смотришь, как оно выглядит, и допиливаешь. Это подводит меня к следующей теме: использование специализированных инструментов для ИИ-прототипирования, которые умеют больше, чем просто понимать текстовые промты.</p><h2 id="инструменты-для-ии-прототипирования" tabindex="-1">Инструменты для ИИ-прототипирования <a class="header-anchor" href="#инструменты-для-ии-прототипирования" aria-label="Permalink to &quot;Инструменты для ИИ-прототипирования&quot;">​</a></h2><p>Хотя универсальные ассистенты типа Gemini, ChatGPT и Claude могут генерить код прототипа по промтам, ландшафт специализированных инструментов для ИИ-прототипирования меняется с бешеной скоростью. На момент написания эти тулзы предлагают разные подходы к фундаментальному компромиссу между точностью (fidelity) и контролем в сгенерированных ИИ прототипах.</p><p>Экосистема созрела для решения конкретных задач прототипирования. Некоторые инструменты заточены на превращение визуального дизайна в код, позволяя дизайнерам загружать скриншоты или наброски и получать рабочие HTML, CSS или React компоненты за секунды. Эта фича «скриншот-в-код» (screenshot-to-code) драматически ускоряет процесс «дизайн-код», что особенно ценно, когда у тебя есть эскизы от руки или макеты в Figma, которые нужно быстро оживить. Инструменты вроде Vercel v0 — яркий пример такого подхода: они обеспечивают высокую точность соответствия оригиналу, но жертвуют некоторым контролем над структурой кода.</p><p>Другие платформы фокусируются на генерации полноценных приложений через диалоговые интерфейсы. Они позволяют юзерам описывать функционал на естественном языке и получать реализацию всего стека. Например, дизайнер, которому нужно быстрое приложение без кодинга, может использовать тулзы типа Lovable или Bolt.new, предлагающие высокоуровневые интерфейсы промтов, способные накидать скелет целого приложения. Некоторые дизайнеры говорят, что собирают функциональные прототипы за часы, хотя раньше на это уходили дни, при этом ИИ автоматически разруливает нудные компоненты и паттерны.</p><p>Третья категория интегрирует ИИ прямо в среду разработки, работая как интеллектуальный парный программист на этапе прототипирования. Эти ИИ-прокачанные IDE, такие как Cursor, Windsurf и Cline, позволяют разрабам сохранять больше контроля над процессом генерации кода, при этом получая ускорение от ИИ. Различие часто кроется в философии рабочего процесса: одни ставят в приоритет автоматическое применение изменений для быстрых экспериментов, другие требуют явного подтверждения правок для более осторожной итерации.</p><p>Общая черта всех этих подходов — способность сжать путь от концепта до рабочего прототипа. Однако они значительно различаются по двум ключевым измерениям, определяющим их полезность для разных юзеров и кейсов.</p><p><strong>Точность (Fidelity)</strong> — это то, насколько сгенерированный результат соответствует твоим вводным или намерению. Инструменты «скриншот-в-код» обычно выдают высокую визуальную точность, но могут нагенерить код, который не бьется с твоими архитектурными предпочтениями. Разговорные инструменты могут интерпретировать твои требования более вольно, создавая рабочие, но шаблонные реализации, требующие доработки.</p><p><strong>Контроль (Control)</strong> — это твоя возможность направлять и изменять процесс генерации. Некоторые инструменты работают как «черные ящики», выдающие готовый результат, другие позволяют итеративно улучшать код через диалог или прямое редактирование. Это измерение становится критичным, когда тебе нужны специфические архитектурные паттерны, оптимизация производительности или интеграция с существующей кодовой базой.</p><p>Понимание этих компромиссов помогает выбрать правильный инструмент. Дизайнер, проверяющий новый паттерн взаимодействия, может выбрать точность и скорость, забив на контроль над деталями реализации. Разработчик, исследующий техническую осуществимость, скорее выберет контроль и прозрачность, даже если это потребует больше ручного вмешательства в процесс генерации.</p><p>Ни один из этих инструментов не выдает код уровня продакшена без присмотра человека. Обычно они доставляют то, что я называю «80%-й прототип» — достаточно функциональный, чтобы протестировать концепцию и показать стейкхолдерам, но требующий дополнительной работы для деплоя в прод. Оставшиеся 20% часто включают усиление безопасности, оптимизацию производительности, обработку ошибок и архитектурную шлифовку.</p><p>Даже во время быстрого прототипирования беглый ревью кода остается обязательным. Хоть ты и не будешь вылизывать каждую деталь в прототипе, сканирование на наличие очевидных косяков типа засвеченных API-ключей или небезопасной обработки данных предотвратит перетекание проблем на поздние стадии разработки. Большинство современных инструментов обеспечивают прозрачность сгенерированного кода, позволяя тебе инспектировать и понимать, что там вообще насоздавалось.</p><p>Поскольку ландшафт ИИ-прототипирования продолжает эволюционировать, конкретные инструменты, несомненно, будут меняться, но эти фундаментальные соображения — точность против контроля и необходимость человеческого надзора — останутся константами. Ключ в том, чтобы понимать свои цели прототипирования и выбирать подходы, которые бьются с твоими конкретными нуждами, будь то быстрая визуальная реализация, демонстрация функционала или техническое исследование.</p><h2 id="от-концепта-к-прототипу-итеративная-шлифовка" tabindex="-1">От концепта к прототипу: Итеративная шлифовка <a class="header-anchor" href="#от-концепта-к-прототипу-итеративная-шлифовка" aria-label="Permalink to &quot;От концепта к прототипу: Итеративная шлифовка&quot;">​</a></h2><p>Одна из сильных сторон прототипирования с ИИ — это цикл итераций: ты можешь сгенерировать начальную версию, а затем допиливать её, общаясь с ИИ. Вместо того чтобы править код руками, ты просто говоришь ИИ, что нужно изменить (см. Рисунок 6-1). Хотя я топлю за более ответственный подход, чем чистый вайб-кодинг «на шару», быстрый цикл обратной связи — это определенно то, что нужно использовать в прототипах на полную катушку.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><strong>Image Missing</strong><em>Рисунок 6-1. Процесс итеративной доработки прототипа: начальные промты генерируют базовые прототипы, а фидбек разработчика драйвит последующие улучшения, создавая все более отточенные решения через коллаборацию с ИИ.</em></p></div><p>Большинство инструментов для ИИ-прототипирования хранят историю или контекст твоих запросов, и это чертовски полезно. Это значит, что ИИ помнит цель твоего приложения и предыдущие инструкции, так что тебе не нужно каждый раз объяснять всё заново. Сохранение контекста — это визитная карточка среды вайб-кодинга: разговор с ИИ становится логом разработки.</p><p>Вот как может выглядеть типичная итеративная шлифовка:</p><p><strong>Шаг 1: Начальная генерация</strong> Ты даешь промт или вводные данные для создания прототипа:</p><blockquote><p>Сгенерируй базовое приложение для трекинга расходов с формой для добавления трат и таблицей для их отображения.</p></blockquote><p><strong>Шаг 2: Ревью и запуск кода</strong> Ты получаешь сгенерированный код и запускаешь его. Может, он работает, но ты замечаешь вещи, которые можно улучшить. Например, UI функционален, но скучен, или таблица не сортирует расходы.</p><p><strong>Шаг 3: Уточни свои промты</strong> Ты возвращаешься к ИИ и даешь дополнительные инструкции. Например:</p><blockquote><p>Сделай список расходов сортируемым по сумме или дате.</p></blockquote><p>ИИ может модифицировать код, добавив логику сортировки или использовав библиотеку для сортируемых таблиц:</p><blockquote><p>Добавь немного цвета, может, используй современный CSS-фреймворк.</p></blockquote><p>ИИ может интегрировать CSS-библиотеку (типа Tailwind или Bootstrap) или просто добавить кастомные стили, чтобы всё выглядело посимпатичнее:</p><blockquote><p>Добавь валидацию формы, чтобы нельзя было добавить расход без названия и суммы.</p></blockquote><p>ИИ может добавить простую валидацию на фронтенде.</p><p>Каждый из этих промтов модифицирует прототип. Поскольку ИИ понимает контекст (инструменты вроде Cursor и чат-тулзы сохраняют состояние кода), он часто может применить изменения в правильных местах — например, вставить код валидации в форму или переписать рендеринг таблицы, чтобы включить сортируемые колонки.</p><p><strong>Шаг 4: Повторить до готовности</strong> После каждой правки ты проверяешь результат. Если ИИ притащил новый баг или сделал не совсем то, что ты хотел, ты уточняешь или фиксишь это через промты:</p><blockquote><p>Сортировка работает наоборот — пожалуйста, сделай по возрастанию по умолчанию.</p></blockquote><blockquote><p>Новая цветовая схема норм, но сделай шапку темно-синей вместо черной.</p></blockquote><p>Каждый цикл итерации проходит довольно быстро — часто занимая всего несколько секунд обработки — что означает, что ты можешь прогнать дюжину итераций за час. По сравнению с ручным кодингом и проверкой всех этих изменений, подход с ИИ может быть значительно быстрее. Это особенно верно для масштабных изменений, типа рестайлинга или добавления фичи.</p><p>Важно понимать: итерации с ИИ требуют четкой коммуникации. Вот тут-то и вступают в игру твои скиллы промт-инжиниринга. Чем более явно и четко ты опишешь изменение, которое хочешь, тем вероятнее, что ИИ сделает это правильно. Например, фраза «Сделай покрасивее» — это туман. Более конкретный промт дает ассистенту четкое направление:</p><blockquote><p>Примени светлую тему с синей шапкой и увеличь размер шрифта для читабельности.</p></blockquote><p>Если ты используешь инструмент типа Vercel v0 или Lovable, ты можешь даже ткнуть в часть UI через их интерфейс и сказать: «Измени это на X».</p><p>Давай посмотрим на короткий диалог итеративного процесса между разработчиком и ИИ-ассистентом:</p><blockquote><p>Сгенерируй React-компонент для списка дел (to-do list). Он должен отображать список задач и текстовое поле для добавления новой задачи.</p></blockquote><p>ИИ выдает React-компонент со стейтом для задач и рендерит список, инпут и кнопку добавления:</p><blockquote><p>Отлично. Теперь сделай каждую задачу редактируемой и добавь чекбокс, чтобы отмечать выполнение.</p></blockquote><p>ИИ обновляет код, рендерит каждую задачу с чекбоксом и функцией редактирования, соответственно модифицируя стейт. Разработчик запускает аппку и видит, что редактирование работает, но кнопки удаления нет:</p><blockquote><p>Добавь кнопку удаления для каждой задачи.</p></blockquote><p>ИИ добавляет фичу удаления в код:</p><blockquote><p>Макет немного тесноват. Добавь базовый CSS, чтобы добавить воздуха между элементами списка и сделать шрифт чуть крупнее.</p></blockquote><p>ИИ выдает CSS-стили, возможно, как <code>&lt;style&gt;</code> в компоненте или отдельный CSS-сниппет:</p><blockquote><p>Выглядит лучше!</p></blockquote><p>Такой пинг-понг может продолжаться, пока прототип не совпадет с твоим видением. В конце концов, разработчик получает рабочий прототип тудушки с функционалом создания, редактирования, завершения и удаления — и всё это построено через запросы на естественном языке и быстрые выдачи кода от ИИ.</p><p>На протяжении всего этого процесса помни, что разработчик остается режиссером происходящего. ИИ может предложить способ реализации фичи, но ты решаешь, подходит ли это под твои нужды. Иногда реализация от ИИ технически верна, но не то, что ты ожидал (может, он использует другой подход к UI, нежели ты задумывал). Ты можешь либо принять это (если это не вредит целям прототипа), либо дать инструкцию ИИ переделать под твой предпочтительный подход.</p><h2 id="эволюция-прототипа-в-сторону-продакшена" tabindex="-1">Эволюция прототипа в сторону продакшена <a class="header-anchor" href="#эволюция-прототипа-в-сторону-продакшена" aria-label="Permalink to &quot;Эволюция прототипа в сторону продакшена&quot;">​</a></h2><p>Прототип — это, по сути, Proof of Concept (PoC) и инструмент, чтобы понять, что вообще работает, а что нет. Как только он выполнил свою задачу — скажем, вы валидировали дизайн на юзерах или доказали, что фича технически реализуема, — следующим шагом обычно становится превращение этой поделки в боевое приложение. И это критически важный момент. ИИ всё еще может помочь, но теперь кожаным мешкам (разработчикам) придется взять напильник и сгладить все острые углы прототипа. В этом разделе мы разберем ключевые моменты переезда кода из состояния &quot;я его слепила из того что было&quot; в продакшен.</p><p>Для начала внимательно пересмотри архитектуру и структуру кода. Под капотом прототипов часто творится сущий ад. Возможно, весь твой код свалился в один файл, или ради скорости ты забил на все мыслимые best practices. Самое время навести порядок. Например, если прототип был скриптом-портянкой, разбей его на модули; для веб-интерфейса внедри нормальную структуру компонентов; для бэкенда — настрой формальный паттерн MVC (Model–View–Controller).</p><p>Хотя большую часть прототипа написал ИИ, ты, как разработчик, лучше понимаешь архитектурные цели. Ты можешь даже стартовать проект с чистого листа, используя прототип как референс или как &quot;строительные леса&quot;, возможно, переиспользуя куски кода, но в целом относясь к нему как к коду на выброс. Другие могут предпочесть инкрементальный рефакторинг, заставляя ИИ предлагать улучшения или писать тесты, чтобы ничего не отвалилось во время уборки.</p><p>Далее — добавь обработку ошибок и edge cases (граничные случаи). Код прототипа обычно заточен под &quot;солнечный денек&quot;, когда всё работает идеально. Но что, если API отвалится? Что, если инпут пустой? Системно пройдись по каждой фиче и подумай, где она может навернуться.</p><p>ИИ может помочь тебе пробштормить эти граничные случаи с таким промптом:</p><blockquote><p>Какие есть потенциальные сценарии ошибок для этой фичи и как их обработать?</p></blockquote><p>Ассистент, скорее всего, выкатит список сценариев (ошибки сети, кривой ввод, проблемы с конкурентностью), для которых ты сможешь запилить обработку (или попросить ИИ помочь с реализацией). Обеспечение надежности кода — это часть процесса подготовки к проду.</p><p>Твой прототип наверняка не оптимизирован, так что чекни его на предмет неэффективных кусков или дыр в безопасности. Например, ИИ мог засунуть туда наивный алгоритм, который летает на тестовых данных, но на реальных объемах повесит всё к чертям. Найди такие места и оптимизируй. (Подробнее о типичных косяках AI-кода я расскажу в Главе 8).</p><p>Одна из стратегий — прогнать тесты производительности или профилировщики на прототипе, найти бутылочные горлышки, а потом попросить ИИ оптимизировать эту функцию. И обязательно проверь безопасность: аутентификацию, обработку данных. Нередко AI-прототипы используют SQL-запросы без параметризации (привет, SQL-инъекции) или хардкодят чувствительную инфу. Это дерьмо нужно фиксить. Исследование 2021 года показало, что около 40% сгенерированного ИИ кода содержало потенциальные уязвимости. Так что бдительность терять нельзя. Запусти статический анализ и/или тесты безопасности вручную, или скажи ИИ: &quot;Просканируй этот код на проблемы с безопасностью&quot;.</p><p>У прототипов часто нет документации, которую тебе придется добавить по мере формализации кода: внятное, проверенное человеком объяснение каждого модуля спасет жизнь будущим членам команды (и тебе самому, когда ты вернешься к этому коду через пару месяцев). Как только причешешь код, можешь попросить ИИ сгенерить Markdown-документацию к API или README, описывающий работу системы. В Главе 1 мы обсуждали, как ИИ умеет объяснять код — сейчас самое время этим воспользоваться.</p><p>Критически важно тщательно протестировать прототип, как мы учили в Главе 5. Напиши юнит-тесты для основной логики, интеграционные тесты для главных флоу и т.д. Ускорить процесс можно, попросив ИИ накидать тест-кейсы:</p><blockquote><p>Напиши тесты на Jest для компонента туду-листа, покрывающие добавление, редактирование, выполнение и удаление задач.</p></blockquote><p>Затем запусти и подправь то, что он сгенерировал. Наличие хорошего набора тестов даст тебе уверенность во время рефакторинга этого франкенштейна.</p><p>Иногда ты можешь решить полностью заменить определенные куски кода — например, если в прототипе использовалась какая-то &quot;тяп-ляп&quot; библиотека или хак, непригодный для долгой жизни. ИИ ускорит и это. Допустим, твой прототип хранит данные в локальных массивах, но теперь тебе нужна нормальная БД. Промпт может быть таким:</p><blockquote><p>Интегрируй базу данных SQLite для хранения задач вместо массива в памяти.</p></blockquote><p>ИИ даст стартовую точку для интеграции, которую ты уже допилишь.</p><p>Внося эти изменения, разумно переключить тумблер в голове с режима &quot;быстрого прототипирования&quot; на &quot;инженерную дисциплину&quot;. ИИ теперь твой ассистент по улучшению качества кода, а не просто генератор фич на скорость. Динамика меняется: теперь ты оцениваешь каждое предложение ИИ более критично, потому что стабильность и качество выходят на первый план. Как я упоминал в Главе 4, сеньоры могут извлечь огромную пользу из ИИ, потому что знают, что принять, а что исправить. На этом этапе ты будешь включать &quot;сеньора&quot; на полную катушку: у тебя есть видение финальной системы, и ты ставишь ИИ задачи на конкретные улучшения.</p><p>Чтобы приземлить теорию, давай рассмотрим пример. Представь соло-разработчицу Джейн, которая хочет запилить небольшое веб-приложение для конвертации CSV-файлов в графики. Она использует ИИ-ассистента, чтобы накидать быстрый прототип за одни выходные: базовый скрипт на Node.js с API плюс простой фронтенд для загрузки CSV и отрисовки графиков через JS-библиотеку.</p><p>Она показывает прототип паре потенциальных юзеров, получает позитивный фидбек и решает превратить это в реальный продукт (веб-сервис). Вот как она проходит этот путь:</p><h2 id="укрепляем-бэкенд" tabindex="-1">Укрепляем бэкенд <a class="header-anchor" href="#укрепляем-бэкенд" aria-label="Permalink to &quot;Укрепляем бэкенд&quot;">​</a></h2><p>В API прототипа на Node.js не было аутентификации (кто угодно мог лить данные). Для продакшена нужны аккаунты юзеров и авторизация. Она просит ИИ интегрировать систему аутентификации (возможно, на JWT). ИИ выдает заготовку, но Джейн внимательно проверяет её, чтобы убедиться, что пароли нормально хешируются, а токены безопасны. Она также добавляет валидацию входных данных на эндпоинт загрузки (ИИ этого не сделал), используя микс из предложений ИИ и своих правок.</p><h2 id="рефакторинг-фронтенда" tabindex="-1">Рефакторинг фронтенда <a class="header-anchor" href="#рефакторинг-фронтенда" aria-label="Permalink to &quot;Рефакторинг фронтенда&quot;">​</a></h2><p>Изначальный фронт был одним HTML-файлом со скрипт-тегами, тянущими зависимости с CDN. Джейн решает отрефакторить это в структурированное React-приложение для поддерживаемости. Сначала она просит ИИ переделать проект под продакшен-стандарты, используя систему сборки и npm вместо скрипт-тегов. Затем просит помочь интегрировать всё это как React-компоненты. Например, код отрисовки графиков из прототипа превращается в компонент <code>&lt;Chart&gt;</code>. Джейн юзает ИИ, чтобы ускорить написание компонентов, но следит, чтобы управление состоянием (state management) и иерархия компонентов соответствовали лучшим практикам (о чем прототип особо не парился).</p><h2 id="тестирование-и-проверка-производительности" tabindex="-1">Тестирование и проверка производительности <a class="header-anchor" href="#тестирование-и-проверка-производительности" aria-label="Permalink to &quot;Тестирование и проверка производительности&quot;">​</a></h2><p>Джейн пишет юнит-тесты для критических функций (парсинг CSV, трансформация данных). Когда она не уверена насчет граничных случаев, она пингует ИИ:</p><blockquote><p>Какие edge cases мне стоит протестировать для парсинга CSV?</p></blockquote><p>Он предлагает сценарии типа пустых полей и кривых колонок, которые она добавляет в тесты. Она также замечает, что прототип грузил CSV-файлы в память целиком; на больших файлах это положит сервер. Она переписывает код на потоковую обработку (stream processing) и просит ИИ перепроверить логику стримов. Теперь аппка переваривает большие файлы надежнее.</p><h2 id="полировка-ui" tabindex="-1">Полировка UI <a class="header-anchor" href="#полировка-ui" aria-label="Permalink to &quot;Полировка UI&quot;">​</a></h2><p>UI прототипа был утилитарным. Для продукта Джейн тратит немного больше времени на UX. Она просит ИИ порекомендовать адаптивный лейаут и, возможно, интегрировать CSS-фреймворк. ИИ добавляет Bootstrap, который она использует для улучшения визуала (формы, кнопки, верстка). После этого она вручную допиливает некоторые стили. Этот этап полировки меньше про хардкорный кодинг и больше про дизайнерские решения, но ИИ всё равно помогает, выдавая готовый код для стандартных паттернов UI (типа навбара или спиннера загрузки).</p><p>После всех усилий бывший кривой прототип превращается в куда более чистое, безопасное и масштабируемое приложение, готовое к реальным юзерам. Джейн деплоит его с уверенностью, потому что добавила тесты и проверила сгенерированный код. Весь процесс от прототипа до прода занял у неё пару недель, тогда как написание всего продукта с нуля заняло бы гораздо больше времени. ИИ ускорил создание начального прототипа и продолжил помогать при переходе, но человеческий надзор Джейн и реструктуризация были незаменимы для достижения продакшен-качества.</p><h2 id="решаем-проблемы-ai-прототипирования" tabindex="-1">Решаем проблемы AI-прототипирования <a class="header-anchor" href="#решаем-проблемы-ai-прототипирования" aria-label="Permalink to &quot;Решаем проблемы AI-прототипирования&quot;">​</a></h2><p>Хотя прототипирование с ИИ — мощная штука, без проблем не обходится. Ты, как разработчик, должен знать о них и уметь их нивелировать. Две зоны особого риска — это раздувание функционала (scope creep) и интеграция.</p><p>Поскольку с ИИ добавлять фичи слишком легко, может возникнуть соблазн пилить и пилить, добавляя &quot;еще одну штучку&quot; в прототип. Это явление называется scope creep. Это может привести к постоянно растущему монстру, который пытается стать финальным продуктом. Помни о цели прототипа: сфокусироваться на ключевом вопросе, на который ты хочешь получить ответ, или на демонстрации основного экспириенса. Если ты обнаруживаешь, что пилишь системы логина, процессинг платежей и т.д. — спроси себя, реально ли это нужно на этапе прототипа? Возможно, лучше поставить заглушки (ИИ может сгенерить фейковый флоу логина, чисто для симуляции). Удержание фокуса сэкономит время и облегчит процесс выбрасывания или переделки кода позже.</p><h2 id="держи-фокус" tabindex="-1">Держи фокус <a class="header-anchor" href="#держи-фокус" aria-label="Permalink to &quot;Держи фокус&quot;">​</a></h2><p>Запиши цель своего прототипа (&quot;Показать, что юзеры могут загрузить CSV и получить график для проверки жизнеспособности идеи&quot;) и используй это как Полярную звезду. Используй ИИ, чтобы быстро достичь этой цели, и сопротивляйся соблазну заниматься &quot;позолотой&quot; (gold-plating) прототипа.</p><p>Во-вторых, вопрос интеграции с реальными системами. Прототипы часто используют мок-данные или упрощенные подсистемы. Если твой AI-прототип юзает фейковые данные или локальный файл, интеграция с реальными базами или сервисами в проде может оказаться нетривиальной задачей. Помни при прототипировании, что некоторые углы были срезаны. Например, может быть, имейлы в прототипе реально не отправлялись, а просто логировались в консоль. В проде тебе понадобится реальный почтовый сервис. ИИ поможет интегрировать их позже, но полезно вести учет: держи список &quot;вещей, которые надо решить, если пойдем дальше&quot;. Так ты не забудешь, какие части были временными костылями. Если работаешь в команде, четко коммуницируй это. Например, можно оставлять комменты в коде: <code>// TODO: интегрировать реальный email-сервис здесь</code>. Многие AI-тулзы сами добавляют такие TODO-комменты, когда генерируют упрощенное решение, что весьма полезно.</p><p>Предвидя эти челленджи, ты сможешь использовать AI-прототипирование эффективно, не попадая в его ловушки. При вдумчивом подходе результатом станет надежный прототип, разработанный в рекордные сроки, готовый либо трансформироваться в финальный продукт, либо быть отложенным в сторону после извлечения уроков.</p><h2 id="итоги-и-следующие-шаги" tabindex="-1">Итоги и следующие шаги <a class="header-anchor" href="#итоги-и-следующие-шаги" aria-label="Permalink to &quot;Итоги и следующие шаги&quot;">​</a></h2><p>В этой главе вы увидели, как вайб-кодинг с поддержкой ИИ турбирует процесс прототипирования. Позволяя ИИ брать на себя тяжелую работу по генерации кода, разработчики могут переходить от концепта к рабочей модели с беспрецедентной скоростью. Я рассказал про инструменты вроде Vercel v0 для генерации UI, Lovable для фуллстек-прототипов и усиленные ИИ IDE, такие как Cursor и Windsurf — каждый из них закрывает разные аспекты быстрого прототипирования. Я также подчеркнул итеративную природу процесса: генерация, тест и доработка в быстрых циклах, где промпты на естественном языке направляют изменения.</p><p>Хотя прототипирование с ИИ может выдать функциональное демо за часы, мы также обсудили критически важный переход к продакшену. Посыл ясен: прототип — это не финальный продукт. Это черновик. Разработчики должны рефакторить и укреплять код, при этом ИИ продолжает ассистировать в этом путешествии (предлагая улучшения, генерируя тесты и т.д.). Кейсы людей и команд, использующих эти техники, подсвечивают реальный буст продуктивности — прототипы строятся за дни вместо недель, что позволяет быстрее получать фидбек от юзеров и принимать бизнес-решения.</p><p>К этому моменту ты должен осознать, как вайб-кодинг превращает прототипирование в мозговой штурм с ассистентом, а не в унылое набивание бойлерплейта. Это фундаментально другой вайб: более разговорный, более высокоуровневый и гораздо более быстрый. Однако ты также увидел важность сохранения фокуса на качестве кода даже в быстром прототипе — и уж точно при его эволюции за пределы стадии прототипа.</p><p>В Главе 7 я смещу фокус с быстрого прототипирования на полноценную разработку веб-приложений с помощью ИИ. В то время как прототипирование исследует возможности, полномасштабная разработка требует системных подходов к архитектуре, реализации и деплою.</p>`,102)])])}const g=i(h,[["render",l]]);export{o as __pageData,g as default};
