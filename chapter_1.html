<!DOCTYPE html>
<html lang="en-US" dir="ltr">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Глава 1. Интро: Что за зверь такой — Вайб-кодинг? | Beyond Vibe Coding</title>
    <meta name="description" content="A book about AI in software development">
    <meta name="generator" content="VitePress v1.6.4">
    <link rel="preload stylesheet" href="/assets/style.DFTx90Kk.css" as="style">
    <link rel="preload stylesheet" href="/vp-icons.css" as="style">
    
    <script type="module" src="/assets/app.C1zoMd5E.js"></script>
    <link rel="preload" href="/assets/inter-roman-latin.Di8DUHzh.woff2" as="font" type="font/woff2" crossorigin="">
    <link rel="modulepreload" href="/assets/chunks/theme.CD8LpRzg.js">
    <link rel="modulepreload" href="/assets/chunks/framework.Dn7Y7LSn.js">
    <link rel="modulepreload" href="/assets/chapter_1.md.C3TDLBKN.lean.js">
    <script id="check-dark-mode">(()=>{const e=localStorage.getItem("vitepress-theme-appearance")||"auto",a=window.matchMedia("(prefers-color-scheme: dark)").matches;(!e||e==="auto"?a:e==="dark")&&document.documentElement.classList.add("dark")})();</script>
    <script id="check-mac-os">document.documentElement.classList.toggle("mac",/Mac|iPhone|iPod|iPad/i.test(navigator.platform));</script>
  </head>
  <body>
    <div id="app"><div class="Layout" data-v-5d98c3a5><!--[--><!--]--><!--[--><span tabindex="-1" data-v-0b0ada53></span><a href="#VPContent" class="VPSkipLink visually-hidden" data-v-0b0ada53>Skip to content</a><!--]--><!----><header class="VPNav" data-v-5d98c3a5 data-v-ae24b3ad><div class="VPNavBar" data-v-ae24b3ad data-v-6aa21345><div class="wrapper" data-v-6aa21345><div class="container" data-v-6aa21345><div class="title" data-v-6aa21345><div class="VPNavBarTitle has-sidebar" data-v-6aa21345 data-v-1168a8e4><a class="title" href="/" data-v-1168a8e4><!--[--><!--]--><!----><span data-v-1168a8e4>Beyond Vibe Coding</span><!--[--><!--]--></a></div></div><div class="content" data-v-6aa21345><div class="content-body" data-v-6aa21345><!--[--><!--]--><div class="VPNavBarSearch search" data-v-6aa21345><!----></div><!----><!----><div class="VPNavBarAppearance appearance" data-v-6aa21345 data-v-6c893767><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-6c893767 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div><div class="VPSocialLinks VPNavBarSocialLinks social-links" data-v-6aa21345 data-v-0394ad82 data-v-7bc22406><!--[--><!--]--></div><div class="VPFlyout VPNavBarExtra extra" data-v-6aa21345 data-v-bb2aa2f0 data-v-cf11d7a2><button type="button" class="button" aria-haspopup="true" aria-expanded="false" aria-label="extra navigation" data-v-cf11d7a2><span class="vpi-more-horizontal icon" data-v-cf11d7a2></span></button><div class="menu" data-v-cf11d7a2><div class="VPMenu" data-v-cf11d7a2 data-v-b98bc113><!----><!--[--><!--[--><!----><div class="group" data-v-bb2aa2f0><div class="item appearance" data-v-bb2aa2f0><p class="label" data-v-bb2aa2f0>Appearance</p><div class="appearance-action" data-v-bb2aa2f0><button class="VPSwitch VPSwitchAppearance" type="button" role="switch" title aria-checked="false" data-v-bb2aa2f0 data-v-5337faa4 data-v-1d5665e3><span class="check" data-v-1d5665e3><span class="icon" data-v-1d5665e3><!--[--><span class="vpi-sun sun" data-v-5337faa4></span><span class="vpi-moon moon" data-v-5337faa4></span><!--]--></span></span></button></div></div></div><div class="group" data-v-bb2aa2f0><div class="item social-links" data-v-bb2aa2f0><div class="VPSocialLinks social-links-list" data-v-bb2aa2f0 data-v-7bc22406><!--[--><!--]--></div></div></div><!--]--><!--]--></div></div></div><!--[--><!--]--><button type="button" class="VPNavBarHamburger hamburger" aria-label="mobile navigation" aria-expanded="false" aria-controls="VPNavScreen" data-v-6aa21345 data-v-e5dd9c1c><span class="container" data-v-e5dd9c1c><span class="top" data-v-e5dd9c1c></span><span class="middle" data-v-e5dd9c1c></span><span class="bottom" data-v-e5dd9c1c></span></span></button></div></div></div></div><div class="divider" data-v-6aa21345><div class="divider-line" data-v-6aa21345></div></div></div><!----></header><div class="VPLocalNav has-sidebar empty" data-v-5d98c3a5 data-v-a6f0e41e><div class="container" data-v-a6f0e41e><button class="menu" aria-expanded="false" aria-controls="VPSidebarNav" data-v-a6f0e41e><span class="vpi-align-left menu-icon" data-v-a6f0e41e></span><span class="menu-text" data-v-a6f0e41e>Menu</span></button><div class="VPLocalNavOutlineDropdown" style="--vp-vh:0px;" data-v-a6f0e41e data-v-8a42e2b4><button data-v-8a42e2b4>Return to top</button><!----></div></div></div><aside class="VPSidebar" data-v-5d98c3a5 data-v-319d5ca6><div class="curtain" data-v-319d5ca6></div><nav class="nav" id="VPSidebarNav" aria-labelledby="sidebar-aria-label" tabindex="-1" data-v-319d5ca6><span class="visually-hidden" id="sidebar-aria-label" data-v-319d5ca6> Sidebar Navigation </span><!--[--><!--]--><!--[--><div class="no-transition group" data-v-c40bc020><section class="VPSidebarItem level-0 has-active" data-v-c40bc020 data-v-b3fd67f8><div class="item" role="button" tabindex="0" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><h2 class="text" data-v-b3fd67f8>Book Content</h2><!----></div><div class="items" data-v-b3fd67f8><!--[--><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/Preface.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Preface</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_1.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 1. Introduction</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_2.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 2. The Art of the Prompt</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_3.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 3. The 70% Problem</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_4.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 4. Beyond the 70%</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_5.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 5. Understanding Generated Code</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_6.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 6. AI-Driven Prototyping</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_7.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 7. Building Web Applications</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_8.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 8. Security and Reliability</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_9.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 9. Ethical Implications</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_10.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 10. Autonomous Agents</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/chapter_11.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Chapter 11. The Future</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/about.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>About the Author</p><!--]--></a><!----></div><!----></div><div class="VPSidebarItem level-1 is-link" data-v-b3fd67f8 data-v-b3fd67f8><div class="item" data-v-b3fd67f8><div class="indicator" data-v-b3fd67f8></div><a class="VPLink link link" href="/index_page.html" data-v-b3fd67f8><!--[--><p class="text" data-v-b3fd67f8>Index</p><!--]--></a><!----></div><!----></div><!--]--></div></section></div><!--]--><!--[--><!--]--></nav></aside><div class="VPContent has-sidebar" id="VPContent" data-v-5d98c3a5 data-v-1428d186><div class="VPDoc has-sidebar has-aside" data-v-1428d186 data-v-39a288b8><!--[--><!--]--><div class="container" data-v-39a288b8><div class="aside" data-v-39a288b8><div class="aside-curtain" data-v-39a288b8></div><div class="aside-container" data-v-39a288b8><div class="aside-content" data-v-39a288b8><div class="VPDocAside" data-v-39a288b8 data-v-3f215769><!--[--><!--]--><!--[--><!--]--><nav aria-labelledby="doc-outline-aria-label" class="VPDocAsideOutline" data-v-3f215769 data-v-a5bbad30><div class="content" data-v-a5bbad30><div class="outline-marker" data-v-a5bbad30></div><div aria-level="2" class="outline-title" id="doc-outline-aria-label" role="heading" data-v-a5bbad30>On this page</div><ul class="VPDocOutlineItem root" data-v-a5bbad30 data-v-b933a997><!--[--><!--]--></ul></div></nav><!--[--><!--]--><div class="spacer" data-v-3f215769></div><!--[--><!--]--><!----><!--[--><!--]--><!--[--><!--]--></div></div></div></div><div class="content" data-v-39a288b8><div class="content-container" data-v-39a288b8><!--[--><!--]--><main class="main" data-v-39a288b8><div style="position:relative;" class="vp-doc _chapter_1" data-v-39a288b8><div><h1 id="глава-1-интро-что-за-зверь-такои-—-ваиб-кодинг" tabindex="-1">Глава 1. Интро: Что за зверь такой — Вайб-кодинг? <a class="header-anchor" href="#глава-1-интро-что-за-зверь-такои-—-ваиб-кодинг" aria-label="Permalink to &quot;Глава 1. Интро: Что за зверь такой — Вайб-кодинг?&quot;">​</a></h1><p>ИИ перекраивает то, как мы пишем софт, выкатывая новые парадигмы кодинга: от свободного промптинга до структурированных ассистентов. Представь, что ты пишешь софт, просто описывая хотелки — почти как треплешься с коллегой, — а ИИ переводит эти идеи в код. В этом и есть суть <strong>вайб-кодинга</strong> (vibe coding): исследовательского подхода &quot;сначала промпт&quot;, где ты описываешь желаемое на естественном языке, а большая языковая модель (LLM) допиливает остальное. Этот термин недавно вбросил пионер ИИ Андрей Карпаты, чтобы описать новый способ программирования, где разработчики &quot;полностью отдаются вайбам&quot; ИИ-помощника.</p><p>В этой книге я копну глубже: что вайб-кодинг значит для профессиональных разрабов и как он соотносится (и дополняет) то, что я называю <em>ИИ-ассистированной инженерией</em> — более формальным процессом дополненного кодинга. Я разберу, как эволюционирует роль разработчика в эту эпоху &quot;AI-first&quot;, какие инструменты и воркфлоу выжмут максимум эффективности, и как разгребать уникальные проблемы, возникающие, когда спускаешь ИИ с поводка в свою кодовую базу. Мы также глянем, где вайб-кодинг тащит, где он откровенно лажает, и как балансировать между скоростью генерации и мудростью человеческого контроля. К концу книги у тебя будет четкая картинка, как оседлать эти &quot;вайбы&quot; в своей практике — ответственно и эффективно, — чтобы стать не просто более быстрым кодером, а более креативным и влиятельным инженером программных продуктов в эпоху ИИ.</p><p>В этой главе мы разберем, как роль разработчика трансформируется от написания детальных инструкций для машин к коллаборации с ИИ через выражение <em>намерения</em> (см. Рис. 1-1). Мы увидим, почему этот &quot;сдвиг вайба&quot; (vibe shift) в программировании — такая важная штука, как это работает на высоком уровне, и какие возможности (и головняки) это нам несет.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><strong>Изображение отсутствует</strong><em>Рисунок 1-1. Концептуальная иллюстрация программирования намерением. Разработчик дает высокоуровневую спецификацию (&quot;намерение&quot;), а ИИ транслирует её в код. Это подчеркивает сдвиг от написания кода строка за строкой к управлению генерацией кода на высоком уровне.</em></p></div><h2 id="спектр-ии-кодинга-от-ваиб-кодинга-до-ии-ассистированнои-инженерии" tabindex="-1">Спектр ИИ-кодинга: От вайб-кодинга до ИИ-ассистированной инженерии <a class="header-anchor" href="#спектр-ии-кодинга-от-ваиб-кодинга-до-ии-ассистированнои-инженерии" aria-label="Permalink to &quot;Спектр ИИ-кодинга: От вайб-кодинга до ИИ-ассистированной инженерии&quot;">​</a></h2><p>За последний год я наблюдал занятный раскол в том, как разработчики — особенно мидлы и сеньоры в вебе — внедряют ИИ в свой рабочий процесс. На одном конце спектра лежит вайб-кодинг. На другом — то, что я назову ИИ-ассистированной инженерией: дисциплинированный метод вплетения ИИ в каждую фазу разработки, от дизайна до тестов, в рамках четких ограничений. Оба подхода юзают мощный ИИ, но их цели, аудитория и ожидания различаются кардинально. На протяжении всей книги я буду исследовать эти две крайности и то, что они значат для современной веб-разработки.</p><h2 id="подход-ваиб-кодинга-код-через-разговор" tabindex="-1">Подход Вайб-кодинга: Код через Разговор <a class="header-anchor" href="#подход-ваиб-кодинга-код-через-разговор" aria-label="Permalink to &quot;Подход Вайб-кодинга: Код через Разговор&quot;">​</a></h2><p>В вайб-кодинге ты используешь мощные LLM как партнеров по кодингу, позволяя им брать на себя всю черную работу по генерации кода, чтобы ты мог сфокусироваться на целях повыше. Как писали в Business Insider, вайб-кодинг &quot;означает использование ИИ-инструментов... для тяжелой атлетики в кодинге, чтобы быстро пилить софт&quot;. Как говорит CEO NVIDIA Дженсен Хуанг, благодаря ИИ &quot;самый горячий новый язык программирования&quot; — это английский, а не Java или Python. Вместо того чтобы вручную набивать каждую функцию и багфикс, ты взаимодействуешь с ИИ на естественном языке — накидываешь фичи, ревьюишь предложения и итерируешь на основе того, что выдал ИИ.</p><p>Этот подход представляет собой драматический сдвиг от традиционного программирования к ИИ-ассистированной разработке. Обычный кодинг требует тщательного планирования, синтаксической точности и зачастую геморройной отладки. Вайб-кодинг переворачивает игру: &quot;Это на самом деле не кодинг — я просто вижу фигню, говорю фигню, запускаю фигню и копипащу фигню, и оно в основном работает&quot;, — съязвил Карпаты в интервью Business Insider, подчеркивая, как ИИ может превращать высокоуровневые инструкции в рабочий код с минимальными ручными усилиями.</p><p>Разработчики переходят от написания детальных инструкций для компов к дирижированию результатами с помощью ИИ. В качестве примера Карпаты описывает создание веб-приложения путем постоянного принятия предложений ИИ: &quot;Я всегда жму &#39;Принять всё&#39; (Accept All), я больше не читаю диффы... Когда получаю ошибки, просто копипащу их обратно... Иногда LLM не могут пофиксить баг, так что я просто делаю костыль или прошу рандомные изменения, пока ошибка не исчезнет&quot;. Код &quot;разрастается&quot; за пределы того, что он обычно написал бы сам, но проект собирается быстро благодаря итеративному промптингу и фиксам. По сути, вайб-кодинг рассматривает программирование как интерактивную беседу с твоим ИИ-напарником, а не как одиночное ползание по синтаксису и стек-трейсам. Цель — скорость и исследование: получить рабочее решение с минимальным трением.</p><p>Несколько трендов сошлись воедино, чтобы сделать вайб-кодинг возможным. Во-первых, современные ИИ-ассистенты (типа OpenAI Codex, ChatGPT, Anthropic Claude и т.д.) стали чертовски хороши в генерации и исправлении кода. В том же посте Карпаты отмечает, что это &quot;возможно, потому что LLM... становятся слишком хороши&quot; — они переварили огромные куски кода с GitHub и могут выдавать правдоподобные решения для многих задач.</p><p>Во-вторых, появились новые инструменты для разработчиков, чтобы бесшовно интегрировать эти модели в рабочий процесс (о них чуть позже). И наконец, менталитет сообщества разработчиков эволюционирует, чтобы доверять помощи ИИ всё большие куски работы. Это больше не просто автокомплит на стероидах; это передача целых функций или файлов ИИ. На практике вайб-кодинг часто ощущается так, будто у тебя есть бесконечный запас гиперактивных джунов, готовых запилить всё, что ты попросишь — только работают они со скоростью облачных вычислений.</p><p>Одно из самых ошеломляющих обещаний вайб-кодинга — буст продуктивности. Ранние адепты докладывают, что могут создавать фичи или прототипы в десять-сто раз быстрее, чем раньше. Например, инженер Codeium Windsurf Джон Хёстье размышляет: &quot;Зачем быть 10x инженером, если можно быть 100x инженером?&quot; Это намекает, что с правильной ИИ-IDE экстраординарная продуктивность уже в пределах досягаемости. Инструменты вроде Windsurf, IDE с прокачанным ИИ, &quot;могут драматически ускорить время разработки, позволяя достичь этой 100x продуктивности&quot;. Хотя 100x может быть экстремальным сценарием, даже более консервативные исследования находят огромный прирост.</p><p>Разработчики могут генерить бойлерплейт за секунды, фиксить баги в мгновение ока и даже заставлять ИИ писать тесты или доки, сжимая рабочие процессы, которые раньше занимали дни, до пары часов. Больше не ограниченный скоростью печати или памятью, один разраб, вооруженный ИИ, часто может спрототипировать фулл-стек приложение за выходные — то, на что раньше у небольшой команды ушли бы недели. И это не просто хайп; как я отмечал в январском посте 2025 года для <em>Pragmatic Engineer</em>, опросы показывают, что 75% разработчиков уже интегрировали какую-то форму ИИ в свои процессы, и многие компании репортят об улучшении скорости разработки на двузначные или трехзначные проценты. Короче говоря, ИИ-парное программирование превращает мифического &quot;10x инженера&quot; в очень реальный (и достижимый) феномен &quot;100x инженера&quot;.</p><p>Чтобы понять, насколько это революционно, рассмотрим конкретный пример. Разраб хочет запилить простенькое веб-приложение, которое считает слова в скрипте подкаста и оценивает время чтения. Вместо того чтобы начинать с нуля, он открывает среду с ИИ и рассказывает машине свою идею. Через пару минут ИИ выкатывает рабочий прототип. Потом разраб говорит: &quot;Сделай счетчики статистики яркими цветами и добавь экспорт в PDF&quot;, и ИИ обновляет код соответственно. Результат — функциональный инструмент, задеплоенный в один клик — и всё это меньше чем за 10 минут. Этот реальный сценарий (описанный криэйтером, использующим ИИ от Replit) показывает, как вайб-кодинг обеспечивает экстремально быструю, итеративную разработку, движимую высокоуровневыми запросами. Точно так же влетают и не-инженеры: та же статья описывает уволенного маркетолога без бэкграунда в кодинге, который использовал ИИ-ассистента, чтобы создать 100 простых веб-тулзов, которые коллективно вышли в топ Product Hunt. Когда порог создания софта падает так низко, мы не просто повышаем продуктивность бывалых разрабов — мы фундаментально расширяем круг тех, кто вообще может разрабатывать софт.</p><p>Однако вайб-кодинг идет в комплекте с серьезными оговорками. Поскольку ты так много делегируешь ИИ, ты можешь закончить с кодом, который &quot;работает&quot; на &quot;хэппи пасе&quot; (идеальном сценарии), но скрывает под собой минное поле багов или убогих архитектурных решений. Без твердого плана или ограничений LLM может сгенерить решение, которому не хватает нормальной обработки ошибок, проверок безопасности или масштабируемости. По факту, сгенерированный ИИ код иногда построен на соплях: он выглядит солидно, но имеет скрытые проблемы, которые всплывают только в реальных условиях. Я видел случаи, когда разраб на чистом вайбе пилил фичу в рекордные сроки, только чтобы позже обнаружить, что код неэффективен и его хрен поддержишь. Такой &quot;карточный домик&quot; может рухнуть под давлением.</p><p>Например, представь, что просишь ИИ &quot;сбацать систему логина юзеров&quot;. ИИ может быстро выдать рабочий флоу аутентификации, но, возможно, он использует упрощенный метод шифрования или заведомо дырявую библиотеку. Если ты задеплоишь это без глубокой инспекции, ты веришь на слово, что всё надежно. Тертые калачи знают, что это риск: код, крутящийся в проде, должен быть понятным и надежным. Как выразился один эксперт: &quot;Вайб-кодить прямо в продакшн — это явный риск. Большая часть нашей работы как софт-инженеров включает развитие существующих систем, где качество и понимание лежащего в основе кода критически важны&quot;. Вайб-кодинг в своем экстремальном проявлении может обходить эти ворота качества стороной.</p><p>Ещё один челлендж в том, что вайб-кодинг имеет тенденцию забивать на предварительное планирование. Традиционная инженерия ценит проектирование ради ясности и ограничений — продумывание моделей данных, выбор подходящих паттернов и написание хотя бы минимальной спеки. Вайб-кодинг переворачивает это: он стартует без лесов, ныряя сразу в реализацию через промпты. Это может привести к блуждающему процессу разработки. Ты можешь &quot;напромптить&quot; себя в угол — скажем, ИИ выберет подход к управлению состоянием или библиотеку, которую ты не планировал, и теперь тебе придется либо выруливать обратно, либо жить с этим. Без начального чертежа финальная архитектура может быть хаотичной. Это норм для быстрого Proof of Concept, но это геморрой в крупной кодовой базе, где важна последовательность.</p><p>Вайб-кодинг не является по своей сути &quot;плохим&quot;. На самом деле, его появление — часть продолжающейся демократизации программирования. Он снижает барьер для создания софта, так же как это делали ранние low-code платформы или скриптовые языки. Мотивированный не-инженер с четкой идеей потенциально может построить простое приложение на одних только вайбах. А для опытных разрабов вайб-кодинг может быть мощным инструментом для брейншторминга — это как писать псевдокод, но с немедленными, запускаемыми результатами. Ключ в том, чтобы осознавать границы. Скорость без дисциплины может привести к хрупкому софту, поэтому вайб-кодинг требует бдительного человека в контуре управления. Я часто напоминаю разрабам (и себе), что &quot;вайб-кодинг — это не оправдание для низкокачественной работы&quot;. Это должно быть началом решения, а не его концом.</p><h2 id="инженерныи-подход-с-использованием-ai-структура-и-цифровои-напарник" tabindex="-1">Инженерный подход с использованием AI: Структура и цифровой напарник <a class="header-anchor" href="#инженерныи-подход-с-использованием-ai-структура-и-цифровои-напарник" aria-label="Permalink to &quot;Инженерный подход с использованием AI: Структура и цифровой напарник&quot;">​</a></h2><p>На другом конце нашего спектра находится <strong>AI-assisted инжиниринг</strong> — более системный, методичный способ запиливания софта, где AI выступает в роли второго пилота на каждом шагу. Здесь разработчик крепко держит руль. AI-assisted инжиниринг подразумевает использование нейронок на всех этапах традиционного жизненного цикла разработки ПО (SDLC): умный автокомплит, чат-боты, миграции кода, поиск багов, генерация тестов, а также генерация кода — как точечная (функции, модули), так и полная (см. Рис. 1-2).</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><strong>Image Missing</strong><em>Рис. 1-2. Рабочий процесс AI-assisted инжиниринга по принципу &quot;сначала план&quot;: разработчики создают спецификации, скармливают AI-системам целенаправленные промты, ревьюят сгенерированные куски кода и интегрируют одобренные решения в свои проекты.</em></p></div><p>Ты начинаешь с плана (даже если он набросан на салфетке), обрисовывая, что нужно построить, и заранее определяя ограничения и критерии приемки. Затем ты точечно подключаешь AI-инструменты, чтобы ускорить или улучшить части этого плана. В отличие от вайб-кодинга, где &quot;сначала промт&quot;, это можно назвать разработкой &quot;сначала план&quot; (plan-first) с поддержкой AI. Это может быть формальный мини-PRD (короткий документ с требованиями к фиче) или простой чеклист задач. Ключевое отличие в том, что ты заземляешь работу четкими намерениями и ограничениями, прежде чем спустить AI с цепи.</p><p>Представь React-разраба, которому поручили запилить новый интерактивный компонент дашборда. В подходе AI-assisted инжиниринга он начнет с того, что распишет обязанности компонента и его API:</p><blockquote><p>Компонент Дашборда показывает список карточек с аналитикой, поддерживает фильтрацию по диапазону дат, имеет кнопки обновления и экспорта. Он должен тянуть данные из нашего API (с нормальной обработкой ошибок) и обязан следовать нашей дизайн-системе в плане стилей.</p></blockquote><p>Этот набросок — по сути, спека. Разраб может даже накидать быструю модель данных или найти существующие утилиты для переиспользования. Только после этого он зовет AI: например, использует IDE с AI-функциями, чтобы сгенерировать скелет компонента на основе этого описания. Нейронка может выдать стартовую реализацию React-компонента с плейсхолдерами для фетчинга данных и заглушками для обработчиков событий. Поскольку разработчик дал четкие вводные, выхлоп AI с большей вероятностью попадет в нужды проекта (например, использует правильные классы дизайн-системы или дернет верные эндпоинты API). Код не становится сюрпризом; это результат нормально сформулированного запроса.</p><p>AI-assisted инжиниринг не останавливается на генерации кода для одного компонента. Он пронизывает весь жизненный цикл разработки, но в контролируемом режиме. Для рутинных задач автокомплит типа GitHub Copilot может подсказывать следующие несколько строк, пока ты печатаешь, экономя нажатия клавиш при реализации известных паттернов. Например, пока ты пишешь юнит-тест, твой AI-помощник может автодополнять утверждения (assertions), основываясь на имени функции. Кстати о тестах: ты можешь заюзать AI для генерации тест-кейсов, как только фича готова — скармливаешь спеку или код компонента в промт, чтобы получить список граничных случаев (edge cases), которые стоит проверить. Идея в том, чтобы усилить работу инженера, а не заменить её. Ты все еще продумываешь логику и верифицируешь корректность; AI просто снимает с тебя часть тупой, черновой работы (grunt work).</p><p>Когда дело доходит до миграции кода или рефакторинга, AI — это просто манна небесная. Представь, что нужно перегнать классовый React-компонент на современные функциональные хуки. Вместо того чтобы херачить все руками, ты можешь попросить AI-ассистента трансформировать код или хотя бы набросать шаги. Понимая старые и новые паттерны, LLM может выдать черновик отрефакторенного кода, который ты потом отполируешь. Это структурированное использование AI решает четкие задачи (типа &quot;мигрируй этот код с Redux на React Context API&quot;) одну за другой, а не дает AI карт-бланш в духе &quot;сделай мне зашибись&quot;.</p><p>Пожалуй, самая дикая форма AI-assisted инжиниринга — это использование AI для генерации полноценного мини-приложения или фичи по детальной спецификации. Сейчас куча инструментов позволяет ввести описание аппки (что-то типа мини-ТЗ) и получить рабочий код или прототип. Например, разраб может закинуть спеку для:</p><blockquote><p>список задач (to-do list) с фронтендом на React и бэкендом на Node.js, с поддержкой аутентификации юзеров и риал-тайм обновлениями.</p></blockquote><p>AI-тулза развернет структуру проекта, создаст ключевые компоненты и настроит схему базы данных.</p><p>Это не магия; это ускоренная версия того, что делает дотошный инженер при старте нового проекта (создание папок, выбор библиотек, написание бойлерплейта). Важно то, что креативность AI загнана в рамки ограничений из спеки. Результат — MVP, который соответствует твоим требованиям. Опытный разраб, правильно воспринимающий этот выхлоп, не будет считать его продовым кодом с первой попытки. Он отнесется к этому как к первому черновику. Он запустит аппку, напишет или перегенерирует тесты, проверит код на нестыковки или дыры в безопасности и допилит по необходимости. Короче, он применит всю свою инженерную строгость — просто ускоренную способностью AI генерить тонны кода по чертежам.</p><p>Цели AI-assisted инжиниринга отличаются от целей вайб-кодинга. Задача тут — не просто быстро получить работающий код, а получить качественный код более эффективно. Речь о том, чтобы бустануть продуктивность, сохраняя (или даже улучшая) надежность результата. Команда, практикующая AI-assisted инжиниринг, скажет: &quot;Мы хотим пилить эту фичу в два раза быстрее, но без компромиссов по нашим стандартам&quot;.</p><p>Аудитория этого подхода — обычно профессиональные разрабы и команды, у которых уже налажены процессы (код-ревью, тесты, пайплайны деплоя), и они не собираются их херить. Это мидлы и сеньоры, которые видят в AI мощный новый инструмент в своем ящике, а не замену самому ящику. Они наверняка видели, что бывает, когда срезаешь углы, поэтому ценят практики, сохраняющие софт поддерживаемым. (Для сравнения: аудитория вайб-кодинга — это соло-разрабы, клепающие демки, продуктовые чуваки с базовыми знаниями кода и даже новички, которые юзают AI, чтобы закрыть дыры в своих знаниях).</p><p>Ожидания в AI-assisted инжиниринге такие: люди остаются у руля принятия решений, а AI подкидывает идеи или ускоряет процесс. Качество кода, производительность и безопасность остаются во главе угла, поэтому каждый кусок, сгенерированный AI, подвергается такой же проверке, как если бы его написал джун. Относись к AI как к стажеру, а не как к замене. Ты можешь делегировать ему задачи, но ты обязан проверять его работу. Ты же не задеплоишь код, написанный живым стажером, без код-ревью? Ну вот и не деплой код от AI, пока не поймешь, что там внутри. Этот майндсет держит инженерную дисциплину в тонусе.</p><h3 id="разные-маиндсеты-разные-ожидания" tabindex="-1">Разные майндсеты, разные ожидания <a class="header-anchor" href="#разные-маиндсеты-разные-ожидания" aria-label="Permalink to &quot;Разные майндсеты, разные ожидания&quot;">​</a></h3><p>Вайб-кодинг и AI-assisted инжиниринг — это два разных состояния ума. Вайб-кодинг идет сверху вниз и основан на исследовании: ты начинаешь с широкой идеи и позволяешь реализации проявиться через взаимодействие с AI. Это немного похоже на джазовую импровизацию — минимум структуры, куча пространства для творческих риффов, и ты открываешь форму песни по ходу игры. AI-assisted инжиниринг — систематичный и итеративный: больше похоже на классическую композицию, где ты начинаешь с темы или мотива (твои требования) и методично развиваешь её, возможно, используя немного импровизации (предложения AI) в рамках партитуры. И там, и там получается &quot;музыка&quot;, но процесс и результат будут разными.</p><p>Для мидла или сеньора в вебе твои ожидания от каждого подхода — ключевой момент. Если ты вайб-кодишь, ты ждешь сюрпризов. AI может предложить подход, который ты бы сам не написал — может, другую либу или идиому, с которой ты меньше знаком. Часть кайфа — учиться на этих сюрпризах или быстро проскакивать скучные моменты. Но надо ожидать и затыков (hiccups). Энтузиасты вайб-кодинга должны входить в это с открытыми глазами: за тот самый сложный последний рывок отвечать придется им. Магия реальна, но она не тотальна.</p><p>Если ты практикуешь AI-assisted инжиниринг, твои ожидания более взвешенные и, пожалуй, более реалистичные для долгосрочных проектов. Ты ждешь, что AI сэкономит тебе время и, возможно, вдохновит на решение-другое, но не сделает за тебя всю работу. На самом деле, хороший инженер может использовать вайб-промтинг в микродозах внутри большого фреймворка. Например, реализуя четко специфицированный модуль, он может на секунду переключиться в &quot;вайб-режим&quot; и спросить: &quot;Эй, AI, сгенери быструю утилитку для форматирования этих дат&quot;, а потом сразу вернуться в режим инженера, чтобы интегрировать и проверить эту функцию. Установка такая: AI — это коллаборатор, работающий под твоим руководством. Ты скидываешь на него задачи, где он хорош (бойлерплейт, повторяющийся код, общие мазки реализации), а остальное тащишь сам (критическая логика, интеграция, финальный ревью).</p><p>Ожидания здесь включают повышенную продуктивность, меньше глупых ошибок (AI вряд ли опечатается в имени переменной, например) и, возможно, более широкий поиск решений (AI может предложить алгоритм, о котором ты не подумал). Но ты также ожидаешь, что придется инвестировать время в валидацию. Отладка AI-кода — это все еще отладка: ты гоняешь тесты и шагаешь по коду дебаггером, если надо. Разница в том, что ты можешь обнаружить себя за отладкой кода, который написал AI, а это новый опыт со своей кривой обучения. В Главе 5 мы обсосем это подробнее.</p><p>Цели двух подходов подсвечивают фундаментальную разницу: вайб-кодинг оптимизирует скорость в моменте (velocity), тогда как AI-assisted инжиниринг оптимизирует устойчивую скорость и надежность. Вайб-кодер скажет: &quot;Мне надо запустить эту аппку к вечеру, чтобы проверить, работает ли идея&quot;. Инженер скажет: &quot;Мне надо запилить эту фичу быстро, но она должна быть достаточно надежной, чтобы жить в нашей кодовой базе годами&quot;. Первый доволен, если код в принципе фурычит; второму важно, чтобы код был достаточно чистым, чтобы другие могли с ним работать.</p><p>Эти различия естественно привлекают разную аудиторию. Менее опытные разрабы или люди вне инженерной тусовки могут склоняться к вайб-кодингу, потому что он снижает порог входа и дает мгновенное вознаграждение. Я встречал продакт-менеджеров и дизайнеров, балующихся кодом через вайб-промты, которые относятся к AI почти как к Stack Overflow на стероидах, выдающему готовые решения. С другой стороны, прожженные разрабы и инженерные команды предпочитают AI-assisted инжиниринг. Они уже обжигались на хрупком коде, поэтому исходят из позиции &quot;давайте сделаем нормально, даже если используем новые инструменты для ускорения&quot;. Они вкладывают чуть больше усилий на старте (пишут этот мини-PRD, настраивают структуру), чтобы получить профит в долгосроке.</p><h2 id="где-твое-место-на-этом-спектре" tabindex="-1">Где твое место на этом спектре? <a class="header-anchor" href="#где-твое-место-на-этом-спектре" aria-label="Permalink to &quot;Где твое место на этом спектре?&quot;">​</a></h2><p>Велик соблазн спросить: какой подход лучше? Правда в том, что вайб-кодинг и AI-assisted инжиниринг — это не взаимоисключающие категории: они представляют два конца спектра, и реальные рабочие процессы часто смешивают элементы обоих. Разраб может начать проект со взрыва вайб-кодинга, чтобы набросать что-то новое, а потом переключиться в режим инженера, чтобы все это закрепить. Или он может в целом следовать дисциплине AI-инжиниринга, но иногда — для тривиального одноразового скрипта или прототипа на выброс — сказать: &quot;Да похер, просто завайб-кожу это и посмотрю, че будет&quot;. Ключ в понимании компромиссов и использовании правильного подхода в правильном контексте.</p><p>Думай о вайб-кодинге как о скоростном внедорожнике для исследований: он может быстро увезти тебя с проторенной дороги, и он крут для открытий. AI-assisted инжиниринг — это скорее надежный поезд на рельсах: тебе придется сначала проложить пути (план), но это более безопасная ставка, и ты с большей вероятностью доедешь до пункта назначения без схода с рельсов. Мидлы и сеньоры должны уметь управлять обоими транспортными средствами, но выбирать их исходя из задачи. Если цель — инновации или быстрая генерация идей (скажем, на хакатоне или при проверке гипотезы), вайб-кодинг дает инерцию. Просто не забудь все подтянуть, если планируешь переиспользовать этот код. Если цель — построить поддерживаемую продуктовую фичу в профессиональной среде, уклон в сторону AI-assisted инжиниринга гарантирует, что ты не получишь в кодовой базе черный ящик, который никто толком не понимает.</p><p>Одна занятная вещь, которую я заметил: по мере того как разрабы набираются опыта с AI-тулзами, их использование часто естественным образом смещается от &quot;вайбового&quot; конца к инженерному. Поначалу новизна того, что AI генерит целые блоки кода по одному промту, манит — кто бы не хотел, по сути, &quot;наболтать&quot; приложение в реальность?</p><p>Но когда медовый месяц проходит, включается прагматизм. Разрабы начинают видеть, где AI красавчик, а где спотыкается. Они учатся разбивать проблемы на части и скармливать их AI по кусочкам, вместо того чтобы просить все решение целиком. По сути, они превращаются из &quot;промт-художников&quot; в &quot;дирижеров AI-оркестра&quot; — все еще используя креативную мощь AI, но направляя ее умелой рукой и следуя четкой партитуре. В моей собственной практике я стал более продуманным в промтах, часто пишу небольшие куски псевдокода или комменты и прошу AI завершить их, вместо того чтобы задавать открытые вопросы. Так я получаю преимущества вайбовой текучести, но в рамках структуры, которую контролирую я.</p><p>Также стоит отметить, что инструментарий эволюционирует, чтобы поддерживать весь спектр. С одной стороны, у нас есть чат-интерфейсы и среды кодинга на естественном языке, заточенные под вайб-кодинг, где ты можешь даже не видеть код, пока не попросишь. С другой — IDE обрастают AI-фичами, которые бесшовно вливаются в традиционный кодинг: например, AI-линтеры, предлагающие улучшения, генераторы документации, объясняющие код, и боты контроля версий, которые могут автоматически создать Pull Request и предложить изменения для ревью. Эти инструменты поощряют инженерный майндсет, вписываясь в обычный рабочий процесс (правка, ревью, тест и т.д.), при этом используя AI.</p><p>Различие между вайб-кодингом и AI-assisted инжинирингом может со временем размыться по мере появления лучших практик. Мы можем обнаружить, что то, что сегодня ощущается как &quot;вайб&quot;, обрастет защитными ограждениями, а то, что кажется &quot;структурированным инжинирингом&quot;, станет более плавным. Вообще, я бы поспорил, что идеальное будущее — это то, где мы можем без усилий перемещаться вверх и вниз по этому спектру: исследовать креативные решения с AI, когда хотим, но всегда возвращать все в русло надежных инженерных практик, когда придет время закалять и шипить софт.</p><p>Этот спектр подходов представляет собой значительную эволюцию в том, как мы работаем с AI сегодня. Но даже пока мы оттачиваем техники сотрудничества с AI — будь то быстрый вайб-кодинг или структурированные инженерные процессы — формируется более фундаментальная трансформация. Меняется сама природа программирования. Мы уходим от традиционной парадигмы, где разработчики должны переводить свои идеи в явные инструкции, к будущему, где мы можем выражать свои намерения напрямую и позволить AI заняться переводом их в код.</p><p>Этот сдвиг бросает вызов нашим самым базовым представлениям о том, что значит быть программистом. Поколениями наша ценность была привязана к способности думать как машины — разбивать проблемы на дискретные, логические шаги, которые комп может выполнить. Но что происходит, когда машины становятся способными понимать, чего мы хотим, а не только то, что мы приказываем им делать? Вот тут на сцену выходит программирование намерениями (programming with intent), представляющее не просто новый инструмент или технику, а фундаментальное переосмысление роли разработчика.</p><h2 id="за-пределами-строк-кода-программирование-намерениями" tabindex="-1">За пределами строк кода: Программирование намерениями <a class="header-anchor" href="#за-пределами-строк-кода-программирование-намерениями" aria-label="Permalink to &quot;За пределами строк кода: Программирование намерениями&quot;">​</a></h2><p>Десятилетиями программирование означало написание инструкций: строка за строкой, говорящих компьютеру, как что-то сделать. Каждая функция, цикл и условие должны были быть тщательно созданы человеком. Программирование намерениями переворачивает этот сценарий. Вместо того чтобы фокусироваться на низкоуровневой реализации, разработчик фокусируется на исходе или цели: чего программа должна достичь. Ты выражаешь это намерение на высоком уровне (часто на естественном языке), а система AI соображает, какой код нужен для его выполнения.</p><p>Думай об этом так: традиционный кодинг — это как давать кому-то пошаговые указания, куда идти, а кодинг на намерениях — это как назвать пункт назначения и позволить им самим найти лучший маршрут. Фокусируясь на &quot;что&quot; вместо &quot;как&quot;, разработчики могут работать на более высоком уровне абстракции. Этот подход не совсем новый — инструменты визуального программирования, low-code платформы и генераторы кода давно обещали поднять уровень абстракции. Но сегодняшние достижения AI наконец-то делают практичным описание сложного поведения простым языком и получение рабочего кода в ответ.</p><h2 id="восстание-промта-от-инструкции-к-описаниям" tabindex="-1">Восстание промта: От инструкций к описаниям <a class="header-anchor" href="#восстание-промта-от-инструкции-к-описаниям" aria-label="Permalink to &quot;Восстание промта: От инструкций к описаниям&quot;">​</a></h2><p>В сердце этого сдвига лежит скромный промт. Промт — это ввод или вопрос, который ты даешь системе AI-кодинга. По сути, это описание того, что ты хочешь, чтобы программа делала, а не инструкция, как это сделать. Это может ощущаться совсем не так, как написание кода. Например, вместо того чтобы писать цикл для парсинга файла, ты можешь запромтить:</p><blockquote><p>Прочитай этот CSV файл и извлеки email-адреса всех юзеров старше 18.</p></blockquote><p>AI попытается сгенерировать код, который выполняет это описание.</p><p>Почему это происходит сейчас? Стремительный прогресс LLM в понимании и генерации текста, включая языки программирования, перевернул игру. Эти AI-модели обучались на огромных объемах кода и текста на естественном языке. Они могут интерпретировать промт, который выглядит как описание поведения софта, и перевести его в реальный код, реализующий это поведение. Другими словами, они выучили паттерны того, как люди описывают задачи и как эти задачи транслируются в код.</p><p>Этот подъем промт-разработки означает, что как разработчик ты все чаще пишешь описания фич и логики на естественном языке или псевдокоде и позволяешь AI тащить тяжелые мешки с написанием синтаксически верного кода. Промт становится твоей новой единицей мысли. Это лаконичное выражение намерения. Мы перешли от указаний компьютеру &quot;Сделай X, потом Y, потом Z&quot; к фразе &quot;Мне нужно, чтобы X, Y и Z были сделаны&quot; и доверию к AI, что он заполнит пробелы.</p><p>Важно отметить, что написание хорошего промта — это само по себе навык (в который мы нырнем в Главе 3). Мутный промт может привести к некорректному или неэффективному коду, точно так же как мутное требование может сбить с толку человека-программиста. Чем лучше ты можешь артикулировать свое намерение в промте, тем лучше выхлоп AI будет соответствовать твоим нуждам. Именно поэтому многие называют написание промтов новой грамотностью программирования.</p><h2 id="как-это-работает-итеративныи-цикл-и-роль-ии-в-генерации-кода" tabindex="-1">Как это работает: Итеративный цикл и роль ИИ в генерации кода <a class="header-anchor" href="#как-это-работает-итеративныи-цикл-и-роль-ии-в-генерации-кода" aria-label="Permalink to &quot;Как это работает: Итеративный цикл и роль ИИ в генерации кода&quot;">​</a></h2><p>Так как же, черт возьми, ИИ превращает твой поток сознания и свободное описание в реальный рабочий код? Вся магия кроется в способности LLM интерпретировать контекст и генерировать текст. Слово «большая» в «большой языковой модели» (LLM) относится к количеству параметров (внутренних настроек), которых там часто миллиарды. Именно они позволяют модели улавливать сложности как естественного, так и языков программирования. Этих зверей тренировали на публичных репозиториях, форумах, документации и сайтах Q&amp;A, так что они выучили и синтаксис, и семантику — то есть, как этот код вообще используется для решения проблем. Когда ты общаешься с ИИ-кодером, ты подключаешься к этой огромной базе знаний. Давай разложим всё по полочкам:</p><h2 id="понимание-промта" tabindex="-1">Понимание промта <a class="header-anchor" href="#понимание-промта" aria-label="Permalink to &quot;Понимание промта&quot;">​</a></h2><p>Когда ты скармливаешь модели промт (например, «Сгенерируй функцию, которая проверяет, является ли число простым»), она анализирует текст. Современные модели от Google, OpenAI и Anthropic обучались на бесчисленном количестве примеров кода и текста, поэтому они используют статистические паттерны, чтобы догадаться, чего ты от них хочешь. По сути, ИИ пытается предсказать наиболее вероятное продолжение твоего промта кодом, в котором есть смысл.</p><h2 id="использование-контекста" tabindex="-1">Использование контекста <a class="header-anchor" href="#использование-контекста" aria-label="Permalink to &quot;Использование контекста&quot;">​</a></h2><p>Эти системы часто учитывают дополнительный контекст, а не только твою однострочную команду. Например, если ты сидишь в IDE с ИИ-ассистентом, модель может подглядывать в содержимое текущего файла, чекать твой стиль кодирования, комментарии и даже связанные файлы. Весь этот контекст помогает ИИ генерировать код, который вписывается в твой проект, а не выглядит как чужеродный кусок. Это похоже на то, как живой разраб читает окружающий код и доки, чтобы понять, что делать дальше.</p><h2 id="генерация-кода" tabindex="-1">Генерация кода <a class="header-anchor" href="#генерация-кода" aria-label="Permalink to &quot;Генерация кода&quot;">​</a></h2><p>Как только модель поняла (или сделала лучшую догадку) твоё намерение, она начинает кодить. Под капотом она делает это по одному токену за раз (токен — это кусок слова или символа кода), используя вероятности, усвоенные при обучении. Модель не «думает» в привычном смысле; у неё нет компилятора или рантайма, чтобы проверить код. Она просто чертовски хороша в продолжении текста так, чтобы получился корректный код, потому что видела миллионы примеров. Если промт и контекст четкие, результат может быть пугающе точным и даже следовать лучшим практикам.</p><h2 id="валидация-под-присмотром-человека" tabindex="-1">Валидация под присмотром человека <a class="header-anchor" href="#валидация-под-присмотром-человека" aria-label="Permalink to &quot;Валидация под присмотром человека&quot;">​</a></h2><p>Важный момент: ИИ не бежит деплоить твое приложение за тебя. Ты всё ещё в контуре. Ты просматриваешь сгенерированный код, тестируешь его, можешь принять или переделать. Часто ИИ может объяснить, что он там понаписал, если попросишь. Роль ИИ — это роль ассистента, который накидывает черновик, но ты, разработчик, остаешься тем самым «decision maker», который гарантирует, что код правильный и не положит прод.</p><p>Что реально впечатляет, так это скорость — секунды, а то и меньше. Если смотреть с высоты птичьего полета: твое описание (промт) летит в движок предсказаний (LLM), который выплевывает вероятный код. И хотя внутри там сложная математика и слои нейросетей, для юзера это ощущается как коллаборация с экспертом, который мгновенно вспоминает, как реализовать практически любую хрень.</p><p>Ключевая фишка вайб-кодинга (программирования от намерения) — это итеративный, совместный процесс. Ты не пишешь один идеальный промт, чтобы потом откинуться в кресле, пока ИИ пишет всю программу без сучка и задоринки. На практике это пинг-понг, цикл обратной связи, который постепенно превращает смутную идею в отполированный код.</p><p>Типичный цикл выглядит примерно так:</p><p><strong>Шаг 1: Ты описываешь, что тебе нужно</strong> Это твой начальный промт. Например: <em>Сгенерируй функцию для расчета ежемесячных платежей по кредиту, учитывая тело кредита, процентную ставку и срок.</em></p><p><strong>Шаг 2: ИИ выкатывает начальное решение</strong> ИИ генерит код функции с параметрами и формулой. Может даже комменты добавить, объясняя, что к чему.</p><p><strong>Шаг 3: Ты смотришь и тестишь</strong> Ты глядишь на код. В нем есть смысл? Обрабатывает ли он краевые случаи (edge cases)? Делаешь быстрый тест: а что, если ставка 0%? Работает? Замечаешь, что этот сценарий он, скорее всего, зафакапил.</p><p><strong>Шаг 4: Ты уточняешь запрос или код</strong> Если код не идеален (а с первого раза так обычно и бывает), допиливай. Можешь снова пнуть ИИ («Измени функцию, чтобы она нормально обрабатывала ставку 0%») или поправить код руками и сказать ИИ: «Объясни эту часть», если что-то мутно. Это помогает исправить недопонимания.</p><p><strong>Шаг 5: ИИ допиливает решение</strong> ИИ берет твой фидбек и корректирует код. Теперь функция проверяет нулевую ставку и не падает.</p><p><strong>Шаг 6: Повторять до готовности</strong> Крутишь этот цикл, пока не будешь доволен. Может, потом попросишь ИИ написать юнит-тесты, чтобы убедиться, что всё работает как часы. Он пишет, ты запускаешь. Профит.</p><p>Эта коллаборация напоминает парное программирование, где один партнер — человек, а второй — ИИ. Человек задает направление и знает высокоуровневые требования, а ИИ кидает предложения, пишет бойлерплейт и ускоряет нудную работу. Поодиночке они не так эффективны в сложных задачах: ИИ нужно направление и валидация, а человеку нужно скинуть рутину на ИИ, чтобы двигаться быстрее.</p><p>Критически важно: итерация — это не только исправление багов, это эволюция решения. Ты можешь начать с очень грубого промта, а потом уточнять свои намерения, глядя на то, что выдает ИИ.</p><p>Это поощряет дух экспериментов. Если первая попытка — говно, ты не потратил много времени — просто уточни промт или подкрути код и попробуй снова. В традиционном кодинге написать модуль только для того, чтобы выкинуть его в помойку — это боль, но с ИИ цена ошибки низкая, что подталкивает пробовать разные подходы.</p><h2 id="продуктивность-доступность-и-меняющаяся-природа-программирования" tabindex="-1">Продуктивность, Доступность и Меняющаяся природа программирования <a class="header-anchor" href="#продуктивность-доступность-и-меняющаяся-природа-программирования" aria-label="Permalink to &quot;Продуктивность, Доступность и Меняющаяся природа программирования&quot;">​</a></h2><p>Почему программирование от намерения — это такая большая тема? У этого сдвига есть несколько серьезных последствий:</p><h3 id="буст-производительности-разработчиков" tabindex="-1">Буст производительности разработчиков <a class="header-anchor" href="#буст-производительности-разработчиков" aria-label="Permalink to &quot;Буст производительности разработчиков&quot;">​</a></h3><p>Самый очевидный плюс — скорость. Разрабы решают задачи быстрее, когда ИИ берет на себя тупую работу. Рутинный код, который руками писать часами (настройка моделей БД, эндпоинты API, скрипты для очистки данных), часто генерится за минуты. Исследования подтверждают: разрабы с GitHub Copilot закрывают задачи значительно быстрее (одно исследование показало сокращение времени на 55%). Умножь это на весь проект, и мы увидим будущее, где циклы разработки сокращаются драматически.</p><h3 id="удержание-разработчиков-«в-потоке»" tabindex="-1">Удержание разработчиков «в потоке» <a class="header-anchor" href="#удержание-разработчиков-«в-потоке»" aria-label="Permalink to &quot;Удержание разработчиков «в потоке»&quot;">​</a></h3><p>Помимо чистой скорости, есть психологический момент. Написание бойлерплейта или гугление синтаксиса выбивает из потока. Когда ИИ берет эти прерывания на себя, ты остаешься сфокусированным на проблеме. Многие говорят, что с ИИ они меньше бесятся от нудных задач и могут сосредоточиться на креативе и архитектуре. Короче, кодить становится приятнее, когда скучную херню делает робот. А счастливый кодер часто пишет лучший код.</p><h3 id="снижение-порога-входа" tabindex="-1">Снижение порога входа <a class="header-anchor" href="#снижение-порога-входа" aria-label="Permalink to &quot;Снижение порога входа&quot;">​</a></h3><p>Раньше программирование требовало зубрежки точного синтаксиса и закидонов разных библиотек. С программированием от намерения часть этой ноши перекладывается на ИИ. Новичок может не помнить, как точно открыть файл или какие параметры у функции графика, но если он может описать, что хочет — ИИ заполнит детали. Это не значит, что любой валенок сможет писать сложные системы с нулем знаний (ты всё ещё должен понимать, что программа делает), но путь до первого полезного результата становится короче. Вполне реально, что эксперты в предметной области (биологи, экономисты) смогут писать прототипы, просто описывая свои нужды, даже не будучи профи-кодерами.</p><h3 id="смена-ролеи-и-навыков" tabindex="-1">Смена ролей и навыков <a class="header-anchor" href="#смена-ролеи-и-навыков" aria-label="Permalink to &quot;Смена ролей и навыков&quot;">​</a></h3><p>По мере того как ИИ берет на себя генерацию кода, роль кожаного мешка эволюционирует. Архитектура, декомпозиция задач и валидация становятся важнее. Ты будешь тратить больше времени, решая <em>что</em> строить и проверяя, <em>почему</em> код работает (или нет), чем набивая синтаксис. Суть «умения кодить» смещается к «умению заставить ИИ кодить». Это демократизирует разработку, но и поднимает планку для профи. Скорее всего, появятся новые best practices по управлению ИИ (об этом я расскажу в Главе 3 и буду возвращаться по ходу книги).</p><h3 id="продуктивность-против-креативности" tabindex="-1">Продуктивность против креативности <a class="header-anchor" href="#продуктивность-против-креативности" aria-label="Permalink to &quot;Продуктивность против креативности&quot;">​</a></h3><p>Забавно, но когда ИИ забирает рутину, люди могут сфокусироваться на высокоуровневом креативе: UX, новые фичи, хитрые алгоритмы, которые ИИ пока не тянет. В идеале ИИ бустит продуктивность на репетативных 80% кода, освобождая твой мозг для изобретательных 20%.</p><p>Однако, тут не одни радуги и единороги. У этого нового стиля есть свои проблемы:</p><h3 id="доверие-и-корректность" tabindex="-1">Доверие и корректность <a class="header-anchor" href="#доверие-и-корректность" aria-label="Permalink to &quot;Доверие и корректность&quot;">​</a></h3><p>Можешь ли ты доверять коду от ИИ? Если ты не проверяешь каждую строку, есть риск пропустить баг. Разрабы должны жестко тестировать и ревьюить сгенерированный код. Вся ответственность на человеке — убедиться, что выхлоп корректен, безопасен и эффективен. Слепо верить ИИ — это риск, о котором мы еще поговорим.</p><h3 id="потеря-низкоуровневых-навыков" tabindex="-1">Потеря низкоуровневых навыков <a class="header-anchor" href="#потеря-низкоуровневых-навыков" aria-label="Permalink to &quot;Потеря низкоуровневых навыков&quot;">​</a></h3><p>Если ты постоянно юзаешь ИИ для рутины, не атрофируется ли твой скилл писать этот код с нуля или дебажить глубоко в кишках? Это как страх, что калькуляторы отучат нас считать в уме. Придется сознательно балансировать между удобством и поддержанием фундаментальных знаний.</p><h3 id="перекроика-рынка-труда" tabindex="-1">Перекройка рынка труда <a class="header-anchor" href="#перекроика-рынка-труда" aria-label="Permalink to &quot;Перекройка рынка труда&quot;">​</a></h3><p>Когда вайб-кодинг станет повсеместным, индустрия начнет ценить другие скиллы. Спрос на людей, умеющих просто клепать шаблонную логику, упадет, а спрос на тех, кто умеет проектировать системы, интегрировать компоненты и верифицировать правильность — вырастет. Работа сместится: ИИ пишет реализацию, люди занимаются дизайном и надзором.</p><p>Кроме того, один из критических факторов в «вайб-кодинге» — размер контекстного окна. Gemini предлагает самое длинное окно из всех моделей, что меняет правила игры в больших проектах. Некоторые модели уже держат в контексте более миллиона токенов, позволяя им «осознавать» целые приложения. Можно скормить ИИ всю кодовую базу для полного понимания.</p><p>Мы еще углубимся в эти компромиссы в конце главы. Но сначала давай познакомимся с инструментами, которые делают этот новый способ кодинга возможным.</p><h2 id="обзор-инструментария-зарождающаяся-экосистема" tabindex="-1">Обзор инструментария: Зарождающаяся экосистема <a class="header-anchor" href="#обзор-инструментария-зарождающаяся-экосистема" aria-label="Permalink to &quot;Обзор инструментария: Зарождающаяся экосистема&quot;">​</a></h2><p>Вайб-кодинг может быть философией, но работает он благодаря новому поколению ИИ-тулзов. Опытным разрабам, желающим войти в этот поток, придется освоить ключевые платформы и модели.</p><p>Этот раздел — быстрая экскурсия по чемоданчику вайб-кодера. Сюда входят Visual Studio Code (VSCode) с его растущей экосистемой ИИ-фич, IDE нового поколения типа Cursor и Windsurf, LLM-ки вроде Claude (в разных версиях) и ChatGPT. Здесь мы не будем касаться фоновых кодинг-агентов, о них я подробно расскажу в Главе 10.</p><p>Читая этот раздел, не парься с запоминанием названий или фич; ландшафт меняется слишком быстро. Цель — понять типы доступных решений.</p><h2 id="vscode-copilot-интегрированная-ии-платформа-от-microsoft" tabindex="-1">VSCode + Copilot: Интегрированная ИИ-платформа от Microsoft <a class="header-anchor" href="#vscode-copilot-интегрированная-ии-платформа-от-microsoft" aria-label="Permalink to &quot;VSCode + Copilot: Интегрированная ИИ-платформа от Microsoft&quot;">​</a></h2><p>VSCode превратился из самого популярного в мире редактора кода в полноценную платформу ИИ-разработки благодаря глубокой интеграции с GitHub Copilot. Это эволюция видения Microsoft: держать ИИ внутри привычной среды, которую миллионы разрабов юзают каждый день.</p><p>GitHub Copilot — это ИИ-ассистент, встроенный в VSCode. Он дает подсказки, объяснения и автоматические реализации на основе промтов и контекста. Что выделяет эту интеграцию, так это её бесшовность — Copilot не ощущается как нашлепка, а как естественное продолжение редактора.</p><p>Ядро ИИ-возможностей VSCode крутится вокруг трех режимов взаимодействия. Во-первых, <strong>inline code autocompletion</strong> (автодополнение в строке), где Copilot подкидывает варианты прямо пока ты печатаешь — от одной строки до целых функций. Пишешь код, а тут появляется «призрачный текст» с предложениями, которые можно принять Табом или забирать по слову.</p><p>Во-вторых, <strong>чат-интерфейс</strong> в боковой панели, где можно потрещать за свой код, задать вопросы или попросить конкретную реализацию. В-третьих, и это, пожалуй, самое мощное — <strong>агентный режим</strong>, который использует вызов инструментов (tool calling) внутри Visual Studio. Даешь ему цель, и он выбирает и выполняет нужные инструменты шаг за шагом. Этот режим может анализировать кодовую базу, предлагать правки в нескольких файлах, запускать команды в терминале, реагировать на ошибки сборки и самоисправляться в цикле, пока задача не будет готова.</p><p>Что делает реализацию Copilot в VSCode особенно крутой, так это поддержка <strong>Model Context Protocol (MCP)</strong>. MCP — это стандартизированный способ для ИИ находить и взаимодействовать с внешними инструментами и данными. Это значит, что Copilot в VSCode может цепляться к базам данных, дергать API, читать документацию и интегрироваться со всей твоей экосистемой. Например, с включенным MCP-сервером GitHub ты можешь попросить Copilot «создать тикет для каждого бага, который мы обсудили», и он полезет в API GitHub и реально их создаст. Расширяемость через MCP превращает Copilot из генератора кода в полноценного ассистента, который шарит не только за код, но и за весь твой рабочий процесс.</p><p>Чтобы эффективно юзать VSCode с Copilot в профессиональной разработке, начни с изучения режимов. Для простых дополнений и рефакторинга полагайся на инлайн-подсказки и иконку с блестками рядом с ошибками — кликни, чтобы получить ИИ-фикс.</p><p>Для задач посложнее переключайся в агентный режим: открой чат и выбери «Agent» в выпадающем меню. Агент заточен под автономные правки в куче файлов. Это мастхэв для сложных тасков, требующих не только правки кода, но и запуска инструментов или команд в терминале. Комбинация привычного интерфейса VSCode с развивающимся Copilot — это мощный вариант для команд, которые хотят энтерпрайз-левел ИИ, не вылезая из любимой IDE.</p><h2 id="vscode-cline-опенсорсныи-автономныи-кодинг-агент" tabindex="-1">VSCode + Cline: Опенсорсный автономный кодинг-агент <a class="header-anchor" href="#vscode-cline-опенсорсныи-автономныи-кодинг-агент" aria-label="Permalink to &quot;VSCode + Cline: Опенсорсный автономный кодинг-агент&quot;">​</a></h2><p>Прежде чем лезть в специализированные ИИ-IDE, стоит глянуть, как Cline (бывший Claude Dev) превращает VSCode в мощную среду разработки. Cline — это другая философия, нежели Copilot от Microsoft. Вместо того чтобы быть тесно интегрированным помощником, он работает как <strong>автономный кодинг-агент</strong>, способный тащить сложные, многоступенчатые задачи от старта до финиша. Это опенсорсное расширение приносит в VSCode возможности, которые часто превосходят проприетарные ИИ-редакторы, сохраняя при этом гибкость.</p><p>Что отличает Cline, так это его реально агентский подход. Когда ты даешь Cline высокоуровневый запрос типа «Создай REST API для управления юзерами с аутентификацией», он не просто генерит бойлерплейт. Он анализирует структуру проекта, планирует реализацию по нескольким файлам, создает иерархию папок, ставит зависимости и даже может прогнать тесты. В процессе он сохраняет прозрачность, показывая каждое запланированное действие (создание файлов, правки, команды терминала) и давая тебе возможность одобрить или поправить каждый шаг. Этот дизайн «человек в контуре» (human-in-the-loop) дает идеальный баланс между автоматизацией и контролем.</p><p>Технические возможности Cline выходят далеко за рамки генерации кода. Он может юзать браузерную автоматизацию, чтобы ресерчить доки по API, дебажить сложные проблемы, анализируя трейсы ошибок по нескольким файлам, и даже взаимодействовать с внешними сервисами через MCP. Для дебага ты можешь просто вставить текст ошибки, и Cline прошерстит кодовую базу, найдет корень зла, предложит фикс, внедрит его и добавит обработку ошибок, чтобы такое не повторилось. Интеграция с MCP означает, что Cline может подключиться к твоей БД, чтобы понять схемы перед написанием запросов, или залезть в таск-трекер.</p><p>Для команд у Cline есть жирные плюсы. Будучи опенсорсом, он позволяет инспектировать код, контрибьютить улучшения или форкать под свои нужды — критично для контор с особыми требованиями к безопасности. Он поддерживает кучу ИИ-провайдеров: Claude от Anthropic, модели OpenAI, Gemini от Google и даже локальные модели через Ollama. Это дает гибкость в выборе модели по цене, качеству или требованиям к привату данных.</p><p>Чтобы юзать Cline на полную катушку, пиши детальные промты с контекстом проекта и ограничениями, используй его способность анализировать всю кодовую базу перед правками и не забывай про итеративность. После того как Cline запилил фичу, можешь сразу потестить её и попросить доработки в том же чате. Комбинация экосистемы VSCode с автономностью Cline дает командам мощный, гибкий и дешевый путь к ИИ-разработке без отказа от привычных инструментов.</p><h2 id="cursor-редактор-кода-на-ai-тяге" tabindex="-1">Cursor: Редактор кода на AI-тяге <a class="header-anchor" href="#cursor-редактор-кода-на-ai-тяге" aria-label="Permalink to &quot;Cursor: Редактор кода на AI-тяге&quot;">​</a></h2><p>Один из флагманов движухи вайб-кодинга — это <strong>Cursor</strong>, IDE на стероидах ИИ, которая быстро набрала популярность среди девелоперов, желающих, чтобы код лился как песня. По сути, Cursor — это редактор, где ИИ стоит во главе угла (на самом деле это форк VSCode), вшивающий передовую генерацию и понимание кода прямо в твою среду разработки.</p><p>Его слоган — «The AI Code Editor», и он заточен под то, чтобы ты писал и правил код, используя обычный человеческий язык. Например, выделяешь функцию и говоришь Cursor’у: «Оптимизируй эту хрень» или «Добавь сюда обработку ошибок», и он моментально выкатывает варианты кода. ИИ в Cursor’е шарит за проект — он индексирует твою кодовую базу и понимает контекст твоих файлов, поэтому его подсказки реально в тему (это тебе не тупой автокомплит). Cursor IDE встраивает мощь LLM прямо в ядро интерфейса. Это как ChatGPT, который выучил твой репозиторий наизусть.</p><p>Под капотом Cursor крутит продвинутые языковые модели (обычно Claude от Anthropic или модели OpenAI, смотря как настроишь). Там есть боковая панель с чатом, где можно перетереть за свой код, и даже режим «Composer» для многоходовой генерации. Сам <strong>Андрей Карпаты</strong> (Andrej Karpathy) использовал Composer в Cursor’е с моделью «Sonnet» в своих экспериментах с вайб-кодингом. Этот сетап позволил ему буквально <em>разговаривать</em> с редактором (через voice-to-text тулзу «SuperWhisper»), и код появлялся на экране, а он его потом либо принимал, либо допиливал.</p><p>Cursor умеет не только генерить код с нуля, но и править существующий по команде. Например, ты можешь спросить:</p><blockquote><p>Можешь сделать смену сертификатов в transport listener попроще?</p></blockquote><p>Cursor поймет, что ты говоришь о своем коде, и предложит прямые правки в нужном файле или считает инфу из релевантных файлов, типа спецификации в markdown (см. Рис. 1-3). В бесплатной версии он чаще кидает дифф (разницу) в чат на апрув; в Pro-версии он может сам накатывать изменения в твой воркспейс.</p><div class="note custom-block github-alert"><p class="custom-block-title">NOTE</p><p><strong>Изображение отсутствует</strong><em>Рисунок 1-3. Интерфейс Cursor — пример нового поколения IDE с интеграцией ИИ. Индексируя проект и итерируя промты, инструменты типа Cursor позволяют «оставить редактор работать, пойти за кофе и вернуться к полностью рабочим фичам», обеспечивая экспоненциальный рост продуктивности.</em></p></div><p>Чтобы юзать Cursor в профессиональном воркфлоу и не облажаться, надо подходить к его возможностям системно. Начни с открытия чата в Cursor и опиши фичу или фикс, который тебе нужен. Например: <em>добавь форму логина юзера с email и паролем, включая валидацию и сообщения об ошибках</em>. Cursor сгенерит нужный код (создаст новые файлы или поправит старые) в черновом варианте. Ты смотришь изменения (он показывает дифф или превью) и жмешь «Apply», чтобы вмержить это в свою кодовую базу. Многие разрабы живут в этом цикле: <strong>промт → ревью → апрув</strong>. Если предложение кривое, уточни промт (например, «Юзай Tailwind CSS для стилей формы») или просто попроси Cursor пофиксить косяки, которые ты заметил («А теперь обработай случай, когда email уже зареган»). По сути, ты ведешь диалог со своим кодом, пока он не станет красавчиком.</p><p>Cursor также шикарно разгребает ошибки и логи. Если запустил код и словил трейсбэк или еррор, копируй это прямо в чат Cursor’а. Часто ИИ проанализирует и предложит фикс. Это превращает дебаггинг в командную работу: вместо того чтобы ручками гуглить Stack Overflow, ИИ Cursor’а часто может ткнуть пальцем в проблему и даже написать патч. Но, братан, проверяй фиксы — ИИ может и набрехать с первого раза.</p><p>Еще один про-тип: юзай способность Cursor’а учитывать несколько файлов. Ты можешь выбрать пачку файлов (или дать ему понять контекст проекта в промте), чтобы он учитывал всю кодовую базу при генерации. Например: <em>добавь новый API эндпоинт на бэке для поддержки формы логина и свяжи его с фронтенд-формой, которую мы только что запилили</em>. Cursor вспомнит код фронта, который только что написал, и поможет скрафтить соответствующую логику на бэке. Этот контекст всего проекта — настоящий геймчейнджер по сравнению с первыми ассистентами, которые видели только один файл.</p><p>Короче, Cursor — это как иметь ИИ-парного программиста внутри IDE 24/7. Он интуитивный (болтаешь с ним на обычном языке) и может править твой код напрямую. Чем больше практикуешься в декомпозиции задач и скармливании Cursor’у четких инструкций, тем больше офигеешь от того, сколько можно успеть за короткое время. Он особенно хорош для итеративной разработки: запилил кусочек, запустил, глянул выхлоп, тут же попросил Cursor подправить или расширить код, и погнали по новой.</p><h2 id="windsurf-ide-на-ии-с-полнои-индексациеи-кодовои-базы" tabindex="-1">Windsurf: IDE на ИИ с полной индексацией кодовой базы <a class="header-anchor" href="#windsurf-ide-на-ии-с-полнои-индексациеи-кодовои-базы" aria-label="Permalink to &quot;Windsurf: IDE на ИИ с полной индексацией кодовой базы&quot;">​</a></h2><p>Еще одна восходящая звезда в ящике инструментов вайб-кодера — это <strong>Windsurf</strong>, среда разработки на ИИ-тяге, которая выводит понимание кода на новый уровень. Windsurf пилит команда Codeium, и его главная фишка — индексация <strong>всей</strong> твоей кодовой базы и использование техник извлечения (retrieval) для скармливания нужных кусков ИИ-модели прямо в процессе работы. На практике это значит, что Windsurf чертовски хорош в работе с жирными проектами, где ответ на твой вопрос может быть размазан по десятку файлов. Его ядро юзает штуку под названием RAG (retrieval-augmented generation) — заумное название для того факта, что он ищет части твоего кода, релевантные твоему промту, и дает этот контекст ИИ, чтобы подсказки не противоречили твоему существующему коду.</p><p>Как это выглядит для разраба? Допустим, ты влетел в большой легаси-проект и надо запилить фичу. С Windsurf ты можешь спросить на человеческом:</p><blockquote><p>Где в этой кодовой базе живет логика аутентификации юзера?</p></blockquote><p>Он прочешет индекс и ткнет тебя носом в нужный файл или даже функцию. Потом ты можешь открыть чат (в Windsurf это называется вид «Cascade», вызывается по Cmd+L) и сказать:</p><blockquote><p>Добавь двухфакторку по телефону в флоу логина.</p></blockquote><p>Поскольку у Windsurf есть контекст твоей логики аутентификации, он может сгенерить изменения, затрагивающие несколько файлов (база данных, API, фронтенд), чтобы это реализовать, принимая осознанные решения, которые стыкуются со структурой твоей системы.</p><p>Режим <strong>Write</strong> в Windsurf может дерзко применять изменения за тебя: он будет создавать новые файлы или править существующие автоматом, а не просто предлагать диффы в сайдбаре. Это дико экономит время: вместо копипасты предложений ты видишь, как твой проект эволюционирует на месте. Windsurf, по сути, пытается действовать от твоего имени, когда уверен в себе, ведя себя как автономный джун, пилящий фичи по всей кодовой базе. (Философия Cursor чуть более консервативна, он просит подтверждения, хотя в Pro-версии тоже есть «auto-apply».)</p><p>Чтобы эффективно юзать Windsurf, полезно понимать его сильные стороны:</p><h3 id="вопросы-и-ответы-по-кодовои-базе-codebase-q-a" tabindex="-1">Вопросы и ответы по кодовой базе (Codebase Q&amp;A) <a class="header-anchor" href="#вопросы-и-ответы-по-кодовои-базе-codebase-q-a" aria-label="Permalink to &quot;Вопросы и ответы по кодовой базе (Codebase Q&amp;A)&quot;">​</a></h3><p>Ты можешь опрашивать свою кодовую базу на простом английском, почти как личный Stack Overflow для твоего проекта. Это мастхэв для огромных легаси-проектов, где поиск места, где определена какая-то хрень, может занять часы. Windsurf ответит за секунды, вытянув инфу из проиндексированного кода.</p><h3 id="глобальные-контекстные-предложения" tabindex="-1">Глобальные контекстные предложения <a class="header-anchor" href="#глобальные-контекстные-предложения" aria-label="Permalink to &quot;Глобальные контекстные предложения&quot;">​</a></h3><p>Так как он скармливает модели релевантные файлы, Windsurf отлично справляется с задачами типа «Отрефактори модуль оплаты, чтобы юзал новую утилиту логирования, которую мы написали», потому что он знает и про модуль оплаты, и про утилиту логирования.</p><h3 id="режимы-работы" tabindex="-1">Режимы работы <a class="header-anchor" href="#режимы-работы" aria-label="Permalink to &quot;Режимы работы&quot;">​</a></h3><p>У Windsurf есть несколько режимов (Autocomplete, Chat, Command и Cascade, как упоминалось). Cascade — это типа супер-чат, где он может учитывать более широкий контекст. Режим Write (внутри чата) реально выполняет изменения. Ты, как инженер, решаешь, сколько автономии ему дать.</p><p>Для команды Windsurf можно внедрить в ежедневную разработку так же, как и Cursor. Выбирая между ними, некоторые разрабы предпочитают Windsurf за его скорость и дерзость (отмечая, что он быстрее генерит и применяет изменения) и за работу с очень большими проектами благодаря индексации. С другой стороны, интерфейс Cursor может показаться более родным для юзеров VSCode. Это не обязательно выбор «или/или» — некоторые инженеры держат под рукой оба, или команды стандартизируют что-то одно.</p><p>В сухом остатке: Windsurf — отличный инструмент, если тебе нужен ИИ-ассистент, который реально «читает доки/код» перед тем, как писать. Это минимизирует шансы на галлюцинации функций или перепутанные переменные, потому что он может подсмотреть, как надо. Чтобы выжать из него максимум, корми его четкими инструкциями и давай волю в режиме Write для больших задач, но не стесняйся использовать его в контролируемом режиме для тонких правок. Всегда ревьювь изменения (он их покажет), особенно для критичного кода. Windsurf умен, но не безгрешен. Если юзать с умом, это как гиперинтеллектуальная IDE, которая знает весь твой проект и может реализовывать идеи сквозь него, давая серьезный буст твоему пропускному каналу.</p><h2 id="модели-ии-ландшафт-для-генерации-кода" tabindex="-1">Модели ИИ: Ландшафт для генерации кода <a class="header-anchor" href="#модели-ии-ландшафт-для-генерации-кода" aria-label="Permalink to &quot;Модели ИИ: Ландшафт для генерации кода&quot;">​</a></h2><p>Ландшафт ИИ-кодинга изменился драматически: теперь за внимание разработчиков грызутся несколько мощных моделей, включая семейства Claude, Gemini и OpenAI. Если раньше доминировала одна модель, то сегодня экосистема предлагает богатый выбор, где у каждой опции свои фишки под разные сценарии кодинга.</p><h3 id="понимание-категории-моделеи" tabindex="-1">Понимание категорий моделей <a class="header-anchor" href="#понимание-категории-моделеи" aria-label="Permalink to &quot;Понимание категорий моделей&quot;">​</a></h3><p>Сегодняшние модели для кодинга обычно делятся на несколько категорий в зависимости от подхода и сильных сторон:</p><h3 id="оптимизированные-по-скорости" tabindex="-1">Оптимизированные по скорости <a class="header-anchor" href="#оптимизированные-по-скорости" aria-label="Permalink to &quot;Оптимизированные по скорости&quot;">​</a></h3><p>Они ставят в приоритет быстрый ответ и идеальны для автокомплита в реальном времени и быстрой итерации. Обычно у них низкая задержка ценой немного сниженной точности на сложных задачах.</p><h3 id="глубокое-рассуждение-deep-reasoning" tabindex="-1">Глубокое рассуждение (Deep reasoning) <a class="header-anchor" href="#глубокое-рассуждение-deep-reasoning" aria-label="Permalink to &quot;Глубокое рассуждение (Deep reasoning)&quot;">​</a></h3><p>Эти тратят больше времени, чтобы «обмозговать» проблему, но превосходят остальных в сложном дебаггинге, архитектурных решениях и многоступенчатом решении проблем. Модели с продвинутым рассуждением могут разбирать сложные баги шаг за шагом.</p><h3 id="мультимодальные-тяжеловесы" tabindex="-1">Мультимодальные тяжеловесы <a class="header-anchor" href="#мультимодальные-тяжеловесы" aria-label="Permalink to &quot;Мультимодальные тяжеловесы&quot;">​</a></h3><p>Некоторые модели могут переваривать не только код и текст, но и картинки, диаграммы и даже видео. Это делает их особенно ценными для понимания визуальной документации или работы с UI/UX элементами.</p><h3 id="open-source-альтернативы" tabindex="-1">Open source альтернативы <a class="header-anchor" href="#open-source-альтернативы" aria-label="Permalink to &quot;Open source альтернативы&quot;">​</a></h3><p>DeepSeek выделяется тем, что предлагает уровень ИИ, сравнимый с закрытыми моделями, без необходимости платить или регаться, хотя там может не хватать фич типа генерации картинок или веб-браузинга.</p><h3 id="выбор-правильнои-модели-под-задачу" tabindex="-1">Выбор правильной модели под задачу <a class="header-anchor" href="#выбор-правильнои-модели-под-задачу" aria-label="Permalink to &quot;Выбор правильной модели под задачу&quot;">​</a></h3><p>Вместо поиска одной «самой лучшей» модели, успешные разрабы теперь подбирают модели под конкретные задачи:</p><ul><li>Для <strong>быстрого прототипирования</strong> и общего кодинга хорошо заходят модели, оптимизированные под скорость и поддержку широкого спектра языков.</li><li>Для <strong>сложного дебаггинга</strong> и системного дизайна выбирай модели с глубоким рассуждением, которые могут методично отслеживать логику.</li><li>Для работы с <strong>большими кодовыми базами</strong> бери модели с огромным контекстным окном, которые могут удерживать в голове весь проект.</li><li>Для <strong>бюджетных команд</strong> open source модели дают отличный вэлью без затрат на подписку.</li></ul><p>Многие инструменты сейчас поддерживают несколько моделей ИИ, включая варианты OpenAI, Claude и Gemini, наряду с проприетарными моделями, позволяя разрабам переключаться между ними в зависимости от текущей задачи.</p><h3 id="практические-советы-для-любои-модели" tabindex="-1">Практические советы для любой модели <a class="header-anchor" href="#практические-советы-для-любои-модели" aria-label="Permalink to &quot;Практические советы для любой модели&quot;">​</a></h3><p>Независимо от того, какую модель выберешь, определенные практики всегда улучшают результат. Во-первых, давай <strong>богатый контекст</strong>. Не проси просто «функцию обработки платежей». Вместо этого покажи свои модели данных, существующие паттерны кода, подходы к обработке ошибок и любые специфические требования. Чем больше контекста дашь, тем лучше выхлоп ляжет в твою кодовую базу.</p><p>Большинство современных кодинг-моделей отлично умеют <strong>ревьюить свой же выхлоп</strong>. После получения сгенерированного кода попроси модель проверить его на потенциальные косяки, предложить улучшения или объяснить свою логику. Эта самокритика часто отлавливает тонкие баги или предлагает оптимизации.</p><p>Используй способность модели <strong>держать контекст разговора</strong>. Начни с базовой реализации, затем постепенно улучшай её через последующие запросы. Этот итеративный подход часто дает лучший результат, чем попытка расписать всё в одном гигантском промте сразу.</p><p>У каждой модели есть тонкие различия в подходе к проблемам. Некоторые любят поболтать и все объяснить, другие более лаконичны. Одни по дефолту юзают новейший синтаксис, другие играют сейвово. Изучение этих повадок поможет тебе крафтить лучшие промты.</p><h3 id="главные-модели" tabindex="-1">Главные модели <a class="header-anchor" href="#главные-модели" aria-label="Permalink to &quot;Главные модели&quot;">​</a></h3><p>Ландшафт ИИ-кодинга меняется ежемесячно: новые модели регулярно бросают вызов устоявшимся лидерам. Конкуренция стала настолько жесткой, что разрабы выигрывают от беспрецедентного выбора и улучшения возможностей. Самое важное — не выбрать «идеальную» модель, а понимать, как использовать сильные стороны тех инструментов, что есть под рукой.</p><p>Многие команды разработчиков сейчас используют <strong>портфельный подход</strong> — юзают быстрые модели для рутины, мощные модели для сложных челленджей и специализированные модели для конкретных областей типа оптимизации БД или фронтенда. Некоторые IDE даже позволяют бесшовно переключаться между моделями посреди задачи.</p><p>Успех приходит от понимания этих опций и стратегического их применения для ускорения твоего рабочего процесса.</p><h3 id="google-gemini-мультимодальныи-кодинг-монстр" tabindex="-1">Google Gemini: Мультимодальный кодинг-монстр <a class="header-anchor" href="#google-gemini-мультимодальныи-кодинг-монстр" aria-label="Permalink to &quot;Google Gemini: Мультимодальный кодинг-монстр&quot;">​</a></h3><p>Семейство <strong>Gemini</strong> от Google представляет собой фундаментальный сдвиг в разработке с помощью ИИ благодаря своим нативным мультимодальным возможностям. В отличие от моделей, которые тренировались в основном на тексте и коде, Gemini была спроектирована с нуля, чтобы бесшовно понимать и работать с текстом, кодом, изображениями, видео и другими форматами данных. Это делает её исключительно мощной для современных рабочих процессов, где визуальный контекст важен так же, как и текстовая инфа.</p><p>Мультимодальная природа Gemini особенно ценна в веб-разработке. Разрабы могут кинуть скриншоты макетов дизайна, и Gemini сгенерит пиксель-перфект реализацию, соответствующую визуальному стилю. Она отлично понимает графики, диаграммы и UI-элементы, что делает её идеальным напарником при переводе визуальных дизайнов в функциональный код. Эта способность выходит за рамки простого распознавания картинок: Gemini может рассуждать о визуальных элементах, понимать паттерны дизайна и поддерживать эстетическую целостность по всему проекту.</p><p>Интеграция Gemini с рабочими процессами через популярные редакторы (VSCode, Cursor, Windsurf) и плагины типа Cline и Code Assist предлагает разрабам мощные опции кастомизации, которые масштабируются от личных предпочтений до общекомандных стандартов. Разрабы могут создавать кастомные команды для повторяющихся задач, устанавливать правила, которые применяются к каждой генерации кода, и поддерживать единые паттерны кодинга в больших репозиториях. Щедрый бесплатный тир делает её доступной для студентов, хобби-кодеров и стартапов, а энтерпрайз-фичи поддерживают сложные требования организаций.</p><p>Что отличает Gemini в ландшафте кодинга, так это её способность глубоко обдумывать проблемы, сохраняя при этом практичную скорость. Модель может переключаться между быстрыми ответами для простых задач и расширенным рассуждением для сложных челленджей, адаптируя свой подход под проблему. Эта гибкость в сочетании с визуальным пониманием делает её особенно эффективной для фуллстек-разработки, где бэкенд-логика и фронтенд-эстетика важны в равной степени.</p><h3 id="claude-виртуоз-логики" tabindex="-1">Claude: Виртуоз логики <a class="header-anchor" href="#claude-виртуоз-логики" aria-label="Permalink to &quot;Claude: Виртуоз логики&quot;">​</a></h3><p>Подход <strong>Claude</strong> от Anthropic к помощи в кодинге строится вокруг прозрачности и глубоких способностей к рассуждению. Семейство Claude, особенно модели <strong>Sonnet</strong>, зарекомендовало себя как исключительно способное в сложных задачах программной инженерии, требующих тщательного анализа и пошагового решения проблем. Что выделяет Claude, так это его способность показывать ход своих мыслей, позволяя разрабам следить за логикой и проверять её перед внедрением решений.</p><p>Фича <strong>Artifacts</strong> представляет собой сдвиг парадигмы во взаимодействии разрабов с ИИ-ассистентами. Вместо того чтобы просто выплевывать код в интерфейс чата, Claude создает выделенное рабочее пространство, где код можно смотреть, редактировать и превьюить в реальном времени. Эта интерактивная среда особенно мощна для фронтенд-разработки, визуализации данных и любых сценариев, где немедленная визуальная обратная связь ускоряет процесс. Разрабы могут итерировать дизайны, тестить функционал и допиливать реализации прямо в рамках одного разговора.</p><p>Claude демонстрирует исключительную производительность на реальных бенчмарках программной инженерии, стабильно занимая топовые места в задачах типа фикса багов, реализации фич и рефакторинга кода. Его сила не просто в генерации кода, а в понимании более широкого контекста софтверных проектов. Claude может анализировать существующие кодовые базы, выявлять паттерны и антипаттерны, предлагать архитектурные улучшения и поддерживать консистентность с установленными стилями кодинга. Это делает его бесценным как для &quot;greenfield&quot; проектов (с нуля), так и для поддержки легаси-систем.</p><p>Подход модели к памяти и управлению контекстом позволяет ей наращивать понимание в ходе длительных сессий кодинга. При работе с большими проектами Claude может извлекать и удерживать ключевую инфу о структуре кодовой базы, проектных решениях и специфичных паттернах. Это накопленное знание позволяет ему давать всё более релевантные и контекстные подсказки по мере прогресса разработки, создавая ощущение работы с членом команды, который со временем всё лучше въезжает в проект, а не с ассистентом без памяти.</p><h3 id="chatgpt-универсальныи-компаньон-кодера" tabindex="-1">ChatGPT: Универсальный компаньон кодера <a class="header-anchor" href="#chatgpt-универсальныи-компаньон-кодера" aria-label="Permalink to &quot;ChatGPT: Универсальный компаньон кодера&quot;">​</a></h3><p><strong>ChatGPT</strong> утвердился как швейцарский нож среди ИИ-ассистентов кодинга, ценный не за узкоспециализированные фичи, а за свою удивительную универсальность и широкую базу знаний. Его позиция в инструментарии разраба уникальна. В то время как другие модели могут интегрироваться прямо в IDE или предлагать специализированные среды кодинга, ChatGPT служит «всегда доступным консультантом по программированию», которого разрабы держат открытым в браузере весь рабочий день.</p><p>Разговорный интерфейс ChatGPT делает его исключительно эффективным для исследовательского решения проблем и обучения. Разрабы регулярно используют его для «метода утенка» (rubber-duck debugging), вставляя проблемный код и обдумывая вопросы в естественном диалоге. Его обширная тренировка позволяет ему распознавать паттерны практически в любом языке программирования, фреймворке или инструменте, находящемся в общем пользовании. Будь то отладка регулярки (regex), понимание мутного сообщения об ошибке или изучение документации незнакомой либы, ChatGPT может дать релевантные инсайты, черпая их из своей всеобъемлющей базы знаний.</p><p>Сила ChatGPT — в его способности наводить мосты между человеческим намерением и реализацией в коде. Он превосходен в двустороннем переводе — конвертации описаний на естественном языке в рабочий код и объяснении сложного кода простым языком. Это делает его бесценным для документации, код-ревью и передачи знаний внутри команд. Разрабы могут вставить незнакомый код и получить четкое объяснение, как он работает, или описать желаемое поведение и получить соответствующие реализации в разных парадигмах программирования.</p><p>Универсальность модели простирается за пределы традиционных языков программирования на конфигурационные файлы, скрипты, форматы данных и предметно-ориентированные языки (DSL). В то время как специализированные инструменты кодинга хороши в своих узких доменах, ChatGPT обеспечивает ценную помощь по всему спектру задач разработки ПО. Эта широта делает его особенно полезным при работе на стыке разных технологий или при столкновении с проблемами, охватывающими несколько областей. Его способность удерживать контекст в длинных беседах позволяет разрабам итеративно исследовать сложные проблемы, оттачивая решения через совместный диалог.</p><h2 id="выбор-правильнои-модели-под-твои-задачи" tabindex="-1">Выбор правильной модели под твои задачи <a class="header-anchor" href="#выбор-правильнои-модели-под-твои-задачи" aria-label="Permalink to &quot;Выбор правильной модели под твои задачи&quot;">​</a></h2><p>Появление этих мощных ИИ-ассистентов — это не просто новая фича, это тектонический сдвиг в разработке софта. Вместо того чтобы смотреть на них как на конкурентов, толковые разрабы понимают: каждое семейство моделей тащит в чем-то своем. <strong>Gemini от Google</strong> рулит там, где нужен визуальный контекст и мультимодальность — особенно в UI/UX и когда надо разобрать дизайнерские спеки. <strong>Claude от Anthropic</strong> сияет в сценариях, требующих глубокой работы мозга, сложного рефакторинга и прозрачной логики решения проблем. А <strong>семейство OpenAI</strong> — это универсальный комбайн с широчайшим кругозором, идеальный для обучения, отладки и задач на стыке разных областей.</p><p>Многие команды сейчас исповедуют «портфельный подход», жонглируя разными моделями для разных задач внутри одного проекта. Типичный воркфлоу выглядит так: Gemini перегоняет дизайн-макеты в черновой код, Claude разгребает сложные архитектурные решения и проводит код-ревью, а ChatGPT закрывает вопросы общего характера и пишет документацию. Такой мультимодельный подход выжимает максимум продуктивности, прикладывая сильные стороны каждого инструмента к конкретному больному месту разработки.</p><p>Поскольку эти модели эволюционируют быстрее, чем ты успеваешь обновить npm-пакеты, ключ к успеху не в поиске одного «самого лучшего» бота, а в умении дирижировать этим оркестром ИИ-ассистентов, чтобы ускорить и улучшить каждый этап жизненного цикла ПО.</p><p>Экосистема молодая, её колбасит. Новые игроки и фичи вылезают каждые пару месяцев. Главный вывод: тебе не нужно пилить свой собственный ИИ на коленке, чтобы программировать <em>с намерением</em> (programming with intent) — инструментов, которые дадут тебе эту силу, уже навалом. В этой книге я ещё не раз пройдусь по разным платформам и покажу, как они вписываются в процесс вайб-кодинга.</p><h2 id="плюсы-и-минусы-ваиб-кодинга-взгляд-без-розовых-очков" tabindex="-1">Плюсы и минусы вайб-кодинга: Взгляд без розовых очков <a class="header-anchor" href="#плюсы-и-минусы-ваиб-кодинга-взгляд-без-розовых-очков" aria-label="Permalink to &quot;Плюсы и минусы вайб-кодинга: Взгляд без розовых очков&quot;">​</a></h2><p>Важно четко понимать, где ИИ-разработка реально тащит, а где она может эпично облажаться. Давай разберем идеальные кейсы, где вайб-кодинг — это царь и бог, и ситуации, где нынешний ИИ всё ещё тупит или требует жесткого вмешательства кожаного мешка.</p><h2 id="идеальные-сценарии-для-ваиб-кодинга" tabindex="-1">Идеальные сценарии для вайб-кодинга <a class="header-anchor" href="#идеальные-сценарии-для-ваиб-кодинга" aria-label="Permalink to &quot;Идеальные сценарии для вайб-кодинга&quot;">​</a></h2><p>Так же как определенные архитектуры подходят под определенные задачи, у вайб-кодинга есть свои «золотые жилы» в ландшафте разработки.</p><h2 id="продуктовая-разработка-«с-нуля-до-единицы»" tabindex="-1">Продуктовая разработка «с нуля до единицы» <a class="header-anchor" href="#продуктовая-разработка-«с-нуля-до-единицы»" aria-label="Permalink to &quot;Продуктовая разработка «с нуля до единицы»&quot;">​</a></h2><p>Вайб-кодинг — это геймчейнджер для запуска новых проектов. Термин «от нуля к единице» (спасибо Питеру Тилю) означает создание чего-то абсолютно нового. С ИИ ты можешь прыгнуть от чистого листа к рабочему прототипу со скоростью света. Нужно поднять веб-приложение, которого раньше не существовало? Ты можешь нагенерить бойлерплейт для фронта, бэка, схемы БД и даже скриптов деплоя за одну бешеную сессию промптинга. Это идеально для стартапов или хакатонов, где цель — быстро проверить идею. Вместо того чтобы неделями настраивать «строительные леса» проекта (весь этот репетативный сетап-код), ИИ сделает это за минуты.</p><p>Многие разрабы травили байки, как запилили MVP за выходные с помощью ИИ-парного программиста — то, на что в соло ушел бы месяц. Быстро материализуя идею в рабочий продукт, ты можешь начать тестировать её на юзерах или стейкхолдерах гораздо раньше. ИИ великолепен в рутине (роутинг, базовые UI-компоненты, стандартный CRUD), что развязывает тебе руки для работы над уникальными фичами продукта.</p><p>Однако, как только твой MVP начнет набирать обороты и поползет в прод, лавочку придется прикрыть. Подход должен измениться. Здесь в игру вступает <strong>ИИ-ассистированная инженерия</strong>. Вайб-кодинг помог тебе быстро всё проверить, но масштабирование требует более осознанных практик. Тебе придется отрефакторить этот наскоро сгенерированный код: добавить нормальную обработку ошибок, покрыть тестами и выстроить четкие архитектурные границы. Переход от прототипа к продукту — это естественная эволюция от исследовательской свободы вайб-кодинга к структурной дисциплине инженерии. Умные команды чувствуют этот момент и корректируют использование ИИ — сохраняя скорость, но вводя необходимые ограничения для устойчивого роста.</p><h2 id="прототипирование-фич-и-crud-приложения" tabindex="-1">Прототипирование фич и CRUD-приложения <a class="header-anchor" href="#прототипирование-фич-и-crud-приложения" aria-label="Permalink to &quot;Прототипирование фич и CRUD-приложения&quot;">​</a></h2><p>Куча энтерпрайз-разработки, особенно в бизнес-приложениях, крутится вокруг CRUD (Create, Read, Update, Delete). Это шаблонная работа, и ИИ в ней чертовски хорош, потому что видел миллиард примеров. Если тебе нужно добавить модуль «Инвентаризация» с экранами и API, вайб-кодинг сожрет это на завтрак. Он выплюнет миграции БД, ORM-модели, эндпоинты API и UI-формы с валидацией — по сути, весь фуллстек — практически без ошибок, потому что эти паттерны заезжены до дыр. Даже если у твоего приложения есть кастомные правила, ты можешь скормить их в промпт и получить годный черновик. Результат: то, что раньше было неделей унылого ковыряния проводов, превращается в полдня промптинга и тестирования под кофеек. Для внутренних тулзов или админок (которые по сути — большие CRUD-приложения) можно почти полностью положиться на генерацию ИИ.</p><p>Инженерный подход становится критичным, когда эти CRUD-операции обрастают сложной бизнес-логикой, правилами валидации данных или интеграцией с существующими системами. Вайб-кодинг накидает структуру, но ИИ-инженерия гарантирует, что твой модуль инвентаризации не ляжет от конкурентных обновлений, сохранит ссылочную целостность и будет следовать паттернам компании. Например, ты вайб-кодишь начальный каркас, а потом переключаешься в режим инженера, чтобы реализовать специфику: алерты о низком запасе, логику распределения по складам или интеграцию с твоей кривой системой авторизации. Ключ в том, чтобы знать, когда перестать генерить и начать шлифовать.</p><h2 id="связующии-код-и-интеграции-glue-code" tabindex="-1">Связующий код и интеграции (Glue code) <a class="header-anchor" href="#связующии-код-и-интеграции-glue-code" aria-label="Permalink to &quot;Связующий код и интеграции (Glue code)&quot;">​</a></h2><p>Нужно поженить два сервиса или API? Обычно это чтение доков и написание кода для перегонки данных из одного формата в другой. ИИ-модели скурили тонны документации и примеров кода, поэтому они могут значительно ускорить интеграцию. Попроси ChatGPT показать, как дернуть API Сервиса А на Языке Б — скорее всего, он выдаст пример с правильными эндпоинтами и даже авторизацией. Соединение систем (типа подключения платежного шлюза к системе заказов или прикручивания аналитики) становится проще, когда ИИ подсказывает бойлерплейт и граничные случаи. Он король стандартных интеграционных паттернов.</p><h2 id="использование-современных-фреимворков" tabindex="-1">Использование современных фреймворков <a class="header-anchor" href="#использование-современных-фреимворков" aria-label="Permalink to &quot;Использование современных фреймворков&quot;">​</a></h2><p>ИИ-ассистенты фактически выучили наизусть мануалы по всем популярным фреймворкам: React, Angular, Django, Rails, Node/Express, Flutter — ты назови. Это значит, что если ты используешь мейнстрим, ИИ сгенерит идиоматический код. Он может выдать новый React-компонент с хуками и стейт-менеджментом или модель Django с правильным классом админки и сериалайзером. Кайф в том, что тебе не надо помнить каждую мелочь — ИИ заполнит пробелы. Вайб-кодинг особенно хорош в современной веб-разработке (HTML/JSX с нужными классами, контроллеры), потому что ИИ видел это миллионы раз. Это как иметь под рукой эксперта по фреймворку, который пишет рутину, пока ты решаешь, что эта фича вообще должна делать.</p><h2 id="генерация-однотипного-кода" tabindex="-1">Генерация однотипного кода <a class="header-anchor" href="#генерация-однотипного-кода" aria-label="Permalink to &quot;Генерация однотипного кода&quot;">​</a></h2><p>Иногда нужно наклепать гору похожего кода (например, кучу похожих эндпоинтов или классов для каждого типа в схеме). Человека от этого тошнит, и он делает ошибки. А ИИ обожает повторяющиеся структуры — покажи ему один-два примера, и он наштампует остальное как на конвейере. Генерация кода оптом экономит кучу времени. Пишешь классы моделей данных для 50 типов записей? Промптишь один пример, просишь сделать для остальных 50 по аналогии. Он сделает это за секунды и, скорее всего, идеально. Итог: ты спасен от дня монотонного кодинга.</p><h2 id="когда-ии-инженерия-должна-выходить-на-первыи-план" tabindex="-1">Когда ИИ-инженерия должна выходить на первый план <a class="header-anchor" href="#когда-ии-инженерия-должна-выходить-на-первыи-план" aria-label="Permalink to &quot;Когда ИИ-инженерия должна выходить на первый план&quot;">​</a></h2><p>Пока вайб-кодинг развлекается в песочнице, в других сценариях без ИИ-инженерии не обойтись. Понимание этих ситуаций спасет тебя от дорогих переписываний и технического долга.</p><p><strong>Сложные алгоритмические реализации требуют инженерного подхода.</strong> Когда ты строишь хитрые структуры данных, пилишь критичные по производительности алгоритмы или решаешь новые вычислительные задачи, тебе нужен полный контроль над каждым байтом. Здесь ИИ — это толковый ассистент, а не генератор кода. Ты можешь попросить его объяснить подходы или проверить твой код, но архитектура и оптимизация — на тебе. ИИ помогает думать, а не решает за тебя.</p><p><strong>Критические системы требуют строгости с самого старта.</strong> Финансовые транзакции, медицина, инфраструктура безопасности — тут не до вайбовых экспериментов. Каждая строка кода требует внимания, тестов и соответствия стандартам (комплаенс). ИИ может подсказать лучшие практики или найти уязвимости, но разработчик держит руку на пульсе. Цена ошибки здесь слишком высока, чтобы гнаться за скоростью генерации.</p><p><strong>Интеграция с легаси — это отдельный круг ада.</strong> Когда работаешь с кодом двадцатилетней выдержки, проприетарными протоколами или системами с вековым техдолгом, паттерн-матчинг вайб-кодинга часто обсирается. Тут нужно глубокое понимание ограничений и методичный рефакторинг. ИИ может помочь объяснить древний код или предложить стратегии модернизации, но реализация требует точности, которую дает только структурированная инженерия.</p><p><strong>Оптимизация производительности</strong> — еще одна сфера, где инженерия бьет вайб. ИИ может быстро выдать рабочий код, но он редко будет оптимальным для &quot;горячих путей&quot; (hot paths). Управление памятью, оптимизация кэша, параллельные вычисления, задержки (latency) — всё это требует понимания железа и ОС. Тут ИИ работает как научный сотрудник: ищет техники, бенчмаркает, но решения принимаешь ты.</p><p>В этих сценариях ИИ — это бустер. Вайб-кодинг процветает на протоптанных дорожках (CRUD, веб-аппы) и там, где нужен быстрый метод проб и ошибок. Это как джун, который прочитал весь GitHub и может мгновенно вспомнить, как это обычно делается. Это мощно, чтобы сдвинуться с места.</p><h2 id="распознавание-точек-перехода" tabindex="-1">Распознавание точек перехода <a class="header-anchor" href="#распознавание-точек-перехода" aria-label="Permalink to &quot;Распознавание точек перехода&quot;">​</a></h2><p>Искусство современной разработки не в выборе одного стула, а в понимании, когда пересаживаться. Успешные разрабы вырабатывают интуицию на эти моменты. Стартуешь новую фичу? Начинай с вайб-кодинга для скорости. Код становится сложным или лезет в критические системы? Переключайся в режим инженера. Пилишь PoC (Proof of Concept) для демо клиенту? Вайб-кодинг домчит тебя туда быстро. Превращаешь PoC в прод? Время включать инженерную дисциплину.</p><p>Эта текучесть — способность бесшовно переходить от быстрой разведки к тщательному строительству — отличает реально эффективных ИИ-разработчиков. Они понимают, что вайб-кодинг и ИИ-инженерия — это просто разные инструменты в ящике, каждый для своей фазы. Цель не выбрать сторону, а стратегически юзать оба подхода.</p><h2 id="где-ии-все-еще-тупит" tabindex="-1">Где ИИ всё ещё тупит <a class="header-anchor" href="#где-ии-все-еще-тупит" aria-label="Permalink to &quot;Где ИИ всё ещё тупит&quot;">​</a></h2><p>Как бы ни были круты нынешние тулзы, это не магия. Есть классы проблем, где ИИ буксует и требует человеческого инсайта или старого доброго кодинга ручками. Знание этих ограничений поможет не завышать ожидания и понимать, когда нужно отобрать штурвал у автопилота.</p><p>Ограничения включают следующее:</p><h2 id="глубоко-сложные-системы" tabindex="-1">Глубоко сложные системы <a class="header-anchor" href="#глубоко-сложные-системы" aria-label="Permalink to &quot;Глубоко сложные системы&quot;">​</a></h2><p>Если ты имеешь дело с очень сложными алгоритмами или новыми проблемами, которых ИИ не видел, он поплывет. Например, реализация свежего алгоритма из научной статьи, написание компилятора или высоконагруженной распределенной системы — это требует глубокого понимания и творческих скачков. ИИ попытается, но может налажать в деталях.</p><p>В таких доменах склонность ИИ выдавать «приблизительно правильный» код приводит к бесконечным правкам. Как мы обсудим в главах 3 и 4, последние 30% корректности даются ИИ очень тяжело. Это «проблема 70%»: ИИ быстро довозит тебя почти до финиша, но последний километр — это ад. Опытный сеньор использует ИИ для генерации скелета, но ядро пишет сам.</p><h2 id="низкоуровневые-оптимизации-и-системное-программирование" tabindex="-1">Низкоуровневые оптимизации и системное программирование <a class="header-anchor" href="#низкоуровневые-оптимизации-и-системное-программирование" aria-label="Permalink to &quot;Низкоуровневые оптимизации и системное программирование&quot;">​</a></h2><p>Нынешние модели натренированы на высокоуровневых языках. Если тебе надо биты гонять, писать оптимизированный C под микроконтроллер или генерить SIMD-инструкции, ИИ ненадежен. Код может выглядеть правдоподобно, но быть неоптимальным или вообще некорректным на уровне железа.</p><p>У ИИ нет концепции кэша процессора или реального времени. Так что для performance-critical кода тебе придется либо досконально проверять предложения ИИ, либо писать всё самому. ИИ может дать шаблон или объяснить ассемблер, но слепо доверять ему тут нельзя.</p><h2 id="уникальные-или-нишевые-фреимворки" tabindex="-1">Уникальные или нишевые фреймворки <a class="header-anchor" href="#уникальные-или-нишевые-фреимворки" aria-label="Permalink to &quot;Уникальные или нишевые фреймворки&quot;">​</a></h2><p>Если ты юзаешь что-то очень новое или редкое, чего не было в обучающей выборке, ИИ этого не знает. Он начнет галлюцинировать: выдумывать функции, которых нет, или использовать устаревшие API. Вышла новая версия фреймворка с ломающими изменениями месяц назад? ИИ не в курсе. Он выдаст код для старой версии. Тут придется лезть в доки и, возможно, дообучать ИИ прямо в промпте, скармливая ему контекст из документации.</p><h2 id="креативныи-ui-ux-дизаин" tabindex="-1">Креативный UI/UX дизайн <a class="header-anchor" href="#креативныи-ui-ux-дизаин" aria-label="Permalink to &quot;Креативный UI/UX дизайн&quot;">​</a></h2><p>Если попросишь ИИ родить абсолютно новый интерфейс, он вряд ли выдаст шедевр. Он сгенерит код для известных паттернов (стандартная форма, дашборд), но инновационный UI — это не к нему. Он просто сошьет франкенштейна из знакомых компонентов. Дизайнеры и фронтендеры всё ещё нужны, чтобы придумывать новый опыт. ИИ сделает «нормально и быстро», но за «вау-эффектом» придется лезть руками.</p><h2 id="интерпретация-намерении-и-требовании" tabindex="-1">Интерпретация намерений и требований <a class="header-anchor" href="#интерпретация-намерении-и-требовании" aria-label="Permalink to &quot;Интерпретация намерений и требований&quot;">​</a></h2><p>ИИ часто тупит, когда требования неявные или противоречивые. Он не понимает цели, кроме того, что ты написал в чат. Если задача размыта («сделай эффективно» — это про память или про скорость?), ИИ может не угадать. Люди лучше понимают контекст и умеют задавать уточняющие вопросы. ИИ также может неверно истолковать инструкции, если не знает доменной специфики (бизнес-правил). Он выдаст логически верный код, который не решает реальную проблему.</p><p>Хороший пример комбо: представь, что ты пишешь новый 3D-движок (сложная система) на Rust (системный уровень, производительность) с уникальными алгоритмами рендеринга. ИИ поможет с бойлерплейтом (создать окно, цикл рендера), но ядро и шейдеры — это твоя головная боль. Если попросишь оптимизировать горячий цикл на ассемблере — проверяй каждую инструкцию.</p><p>У ИИ нет <em>озарений</em>. Это просто поиск паттернов. Если проблема требует инсайта («Эврика!»), ИИ будет просто перебирать варианты кода, которые выглядят похоже, но не работают. Тут нужен человек, который отойдет на шаг назад, подумает и найдет решение. А ИИ потом его закодит.</p><p>Понимание этих сильных и слабых сторон гарантирует, что ты будешь применять вайб-кодинг там, где надо. Используй ИИ для того, в чем он хорош (известные паттерны), и включай свой мозг на уникальных частях. Будь готов вмешаться там, где ИИ лажает (безопасность, сложные алгоритмы).</p><p>Используй ИИ как дополнение: пусть он берет на себя <em>ширину</em> (куча кода, бойлерплейт), а ты — <em>глубину</em> (сложная логика, архитектура). Используй его как бустер на прямых участках и бери руль на поворотах. Это даст лучший результат. Знание того, когда юзать ИИ, а когда полагаться на скилл — вот что делает тебя крутым разработчиком в эту новую эру.</p><p>У каждой новой технологии есть свои плюшки и подвохи. Принимая буст продуктивности от ИИ, важно подходить к этому с холодной головой, понимая ограничения.</p><p>Ключевые преимущества:</p><h2 id="ускорение-циклов-разработки" tabindex="-1">Ускорение циклов разработки <a class="header-anchor" href="#ускорение-циклов-разработки" aria-label="Permalink to &quot;Ускорение циклов разработки&quot;">​</a></h2><p>Проекты летят от концепта к релизу быстрее. ИИ генерит каркас проекта за мгновение, так что ты тратишь больше времени на уникальные фичи.</p><h2 id="улучшенное-прототипирование-и-эксперименты" tabindex="-1">Улучшенное прототипирование и эксперименты <a class="header-anchor" href="#улучшенное-прототипирование-и-эксперименты" aria-label="Permalink to &quot;Улучшенное прототипирование и эксперименты&quot;">​</a></h2><p>Поскольку цена попытки упала (просто опиши хотелку ИИ и получи черновик), разрабы чувствуют больше свободы для экспериментов. Ты можешь напрототипировать несколько подходов, просто меняя промпты, и выбрать лучший. Эта итеративная генерация идей ведет к более креативным решениям.</p><h2 id="знания-на-кончиках-пальцев" tabindex="-1">Знания на кончиках пальцев <a class="header-anchor" href="#знания-на-кончиках-пальцев" aria-label="Permalink to &quot;Знания на кончиках пальцев&quot;">​</a></h2><p>LLM обучались на гигантском корпусе программистских знаний. Нейронка часто «шарит» за какие-то мутные API или знает, как лечить специфичные ошибки, от которых гугл впадает в ступор. На практике она может подкинуть решения или идеи, до которых ты бы сам не допер, делая тебя более эффективным решателем проблем.</p><h2 id="консистенция-и-стандартизация" tabindex="-1">Консистенция и стандартизация <a class="header-anchor" href="#консистенция-и-стандартизация" aria-label="Permalink to &quot;Консистенция и стандартизация&quot;">​</a></h2><p>В командной работе ИИ-ассистент помогает держать строй и насаждать лучшие практики, генерируя код в едином стиле. Если скормить ему стайл-гайд вашего проекта, он проследит, чтобы код у всех выглядел одинаково, без самодеятельности. Даже без специальной дрессировки модели часто выдают «идиоматичный» код (по канону), просто потому что видели миллионы правильных примеров. Это снижает боль на код-ревью: функции выглядят знакомо и следуют конвенциям по дефолту.</p><p>Но давай о грустном. Есть ограничения и компромиссы, о которых надо помнить:</p><h2 id="плавающее-качество-выхлопа" tabindex="-1">Плавающее качество выхлопа <a class="header-anchor" href="#плавающее-качество-выхлопа" aria-label="Permalink to &quot;Плавающее качество выхлопа&quot;">​</a></h2><p>Эти модели не святые. Они могут выдать код, который <em>выглядит</em> рабочим, но внутри кишит неочевидными багами или просто неэффективен. Они могут выбрать устаревший подход (тухляк), просто потому что в их обучающей выборке было много старого легаси-кода. Как разраб, ты должен быть начеку. Ты же не копипастишь код из интернета, не понимая, что он делает? Вот и код от ИИ не принимай бездумно. Во второй части книги мы перетрем за техники нормальной валидации и тестирования того, что нагенерила нейронка.</p><h2 id="мутныи-промт-—-мутныи-код" tabindex="-1">Мутный промт — мутный код <a class="header-anchor" href="#мутныи-промт-—-мутныи-код" aria-label="Permalink to &quot;Мутный промт — мутный код&quot;">​</a></h2><p>Если твой промт размыт и неконкретен, ИИ приходится гадать, что ты имел в виду — и он может не угадать. Например, скажешь ему «отсортируй список имен», он по дефолту сделает алфавитную сортировку. А ты, может, хотел сортировать по длине имени. ИИ не телепат. Поэтому конкретика в промтах (тема Главы 2) — это наше всё. Ты научишься заранее понимать, какие детали нужно разжевывать машине.</p><h2 id="чрезмерная-зависимость-и-атрофия-скиллов" tabindex="-1">Чрезмерная зависимость и атрофия скиллов <a class="header-anchor" href="#чрезмерная-зависимость-и-атрофия-скиллов" aria-label="Permalink to &quot;Чрезмерная зависимость и атрофия скиллов&quot;">​</a></h2><p>Если джуны будут постоянно полагаться на ИИ, разовьют ли они вообще глубокое понимание алгоритмов и дебага? Есть риск атрофии навыков, прямо как с GPS-навигатором — перестаешь ориентироваться на местности. Чтобы не деградировать, важно использовать ИИ как учителя (внимательно смотреть на код и спрашивать «почему так?»), и иногда практиковаться в кодинге без костылей, чисто чтобы не растерять фундаментальные навыки.</p><h2 id="приватность-и-безопасность" tabindex="-1">Приватность и безопасность <a class="header-anchor" href="#приватность-и-безопасность" aria-label="Permalink to &quot;Приватность и безопасность&quot;">​</a></h2><p>Использование облачных ИИ-тулзов часто означает, что ты сливаешь свой код (который может быть проприетарным или секретным) дяде на стороне для анализа. Компаниям стоит об этом задуматься. Многие инструменты решают это через локальные (on-premises) модели или клянутся не сохранять код, но осадочек остается. Плюс есть риск, что ИИ случайно сгенерит кусок кода, подозрительно похожий на что-то из опенсорса под лицензией типа GPL. Это редкость (фильтры работают), но проверять и понимать, что именно выдал ИИ перед интеграцией, — обязательно. Глава 8 погрузит нас в вопросы безопасности и надежности.</p><h2 id="предвзятость-bias-в-выдаче-ии" tabindex="-1">Предвзятость (Bias) в выдаче ИИ <a class="header-anchor" href="#предвзятость-bias-в-выдаче-ии" aria-label="Permalink to &quot;Предвзятость (Bias) в выдаче ИИ&quot;">​</a></h2><p>Модели могут отражать предрассудки, зашитые в их обучающих данных. В контексте кодинга это может быть безобидно — типа предпочтения определенных имен переменных (вечные <code>foo</code>/<code>bar</code>) или предположений о локали юзера. Например, примеры всегда для США. Обычно в генерации кода это не такая жесть, как в других сферах ИИ, но знать об этом стоит. Что хуже — ИИ может быть предвзят к решениям, которые он видел чаще всего, даже если для твоего кейса они не подходят. Глава 9 обсудит предвзятость и прочую этику.</p><h2 id="человеческии-фактор-и-доверие" tabindex="-1">Человеческий фактор и доверие <a class="header-anchor" href="#человеческии-фактор-и-доверие" aria-label="Permalink to &quot;Человеческий фактор и доверие&quot;">​</a></h2><p>Не всем разрабам сразу заходит такой стиль работы. В кодинге есть свой кайф и артистизм, и кому-то кажется, что ИИ это убивает. Плюс, на старте всегда есть недоверие — «А оно точно правильно сделало?» — которое лечится только хорошими практиками и временем. Командам, внедряющим ИИ, нужно время на притирку и обмен опытом. Со временем, как и с любым инструментом, большинство находит баланс: вклад ИИ ценится, а человеческая экспертиза фокусируется на том, что люди делают лучше всего.</p><h2 id="итоги-и-следующие-шаги" tabindex="-1">Итоги и следующие шаги <a class="header-anchor" href="#итоги-и-следующие-шаги" aria-label="Permalink to &quot;Итоги и следующие шаги&quot;">​</a></h2><p>Смена вайба в сторону программирования намерениями дает дикий потенциал: разработка становится быстрее, доступнее и во многом веселее. Но чтобы реализовать этот потенциал, нужно понимать новую динамику: как эффективно базарить с ИИ, как верифицировать его выхлоп и как ответственно встроить это в свои процессы.</p><p>Мое мнение, закаленное работой с этими инструментами и наблюдением за кучей проектов: лучшее применение ИИ — это микс творческого «вайба» и жесткой инженерной гигиены. Поощряйте дикие идеи и быстрые черновики, которые дает ИИ — это наши новые суперсилы. Но направляйте их с мудростью, накопленной десятилетиями разработки: планирование, тесты и понимание того, что вы вообще строите.</p><p>Когда мы ловим этот баланс, мы получаем лучшее от двух миров. Мы получаем софт, который пилится быстрее и, возможно, с большей фантазией, но при этом мы ему доверяем, можем поддерживать и развивать без страха. Именно так мы прокачиваем наше ремесло в эпоху ИИ: не выбирая между вайбом и инженерией, а мастерски владея всем спектром между ними.</p><p>Дальше, Глава 2, исследует искусство создания промтов и коллаборации с ИИ. Держа в голове базу из этой главы, ты готов нырнуть в практическую часть этой новой эры программирования. Это подготовит почву для реальных примеров и глубоких техник промптинга в следующих главах.</p></div></div></main><footer class="VPDocFooter" data-v-39a288b8 data-v-e257564d><!--[--><!--]--><!----><nav class="prev-next" aria-labelledby="doc-footer-aria-label" data-v-e257564d><span class="visually-hidden" id="doc-footer-aria-label" data-v-e257564d>Pager</span><div class="pager" data-v-e257564d><a class="VPLink link pager-link prev" href="/Preface.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Previous page</span><span class="title" data-v-e257564d>Preface</span><!--]--></a></div><div class="pager" data-v-e257564d><a class="VPLink link pager-link next" href="/chapter_2.html" data-v-e257564d><!--[--><span class="desc" data-v-e257564d>Next page</span><span class="title" data-v-e257564d>Chapter 2. The Art of the Prompt</span><!--]--></a></div></nav></footer><!--[--><!--]--></div></div></div><!--[--><!--]--></div></div><!----><!--[--><!--]--></div></div>
    <script>window.__VP_HASH_MAP__=JSON.parse("{\"about.md\":\"BdWnvli_\",\"chapter_1.md\":\"C3TDLBKN\",\"chapter_10.md\":\"DCi3QCBl\",\"chapter_11.md\":\"DSOlOL6n\",\"chapter_2.md\":\"B14Pf0Mv\",\"chapter_3.md\":\"BdbWoyim\",\"chapter_4.md\":\"DxLlQGfE\",\"chapter_5.md\":\"B9BD8wvL\",\"chapter_6.md\":\"DY4RgGqm\",\"chapter_7.md\":\"hH7-h5Bw\",\"chapter_8.md\":\"D9EeakC4\",\"chapter_9.md\":\"CpvHkS4l\",\"index.md\":\"2pAIcPYc\",\"index_page.md\":\"B5PURGsw\",\"preface.md\":\"B3u8ma1b\"}");window.__VP_SITE_DATA__=JSON.parse("{\"lang\":\"en-US\",\"dir\":\"ltr\",\"title\":\"Beyond Vibe Coding\",\"description\":\"A book about AI in software development\",\"base\":\"/\",\"head\":[],\"router\":{\"prefetchLinks\":true},\"appearance\":true,\"themeConfig\":{\"sidebar\":[{\"text\":\"Book Content\",\"items\":[{\"text\":\"Preface\",\"link\":\"/Preface\"},{\"text\":\"Chapter 1. Introduction\",\"link\":\"/chapter_1\"},{\"text\":\"Chapter 2. The Art of the Prompt\",\"link\":\"/chapter_2\"},{\"text\":\"Chapter 3. The 70% Problem\",\"link\":\"/chapter_3\"},{\"text\":\"Chapter 4. Beyond the 70%\",\"link\":\"/chapter_4\"},{\"text\":\"Chapter 5. Understanding Generated Code\",\"link\":\"/chapter_5\"},{\"text\":\"Chapter 6. AI-Driven Prototyping\",\"link\":\"/chapter_6\"},{\"text\":\"Chapter 7. Building Web Applications\",\"link\":\"/chapter_7\"},{\"text\":\"Chapter 8. Security and Reliability\",\"link\":\"/chapter_8\"},{\"text\":\"Chapter 9. Ethical Implications\",\"link\":\"/chapter_9\"},{\"text\":\"Chapter 10. Autonomous Agents\",\"link\":\"/chapter_10\"},{\"text\":\"Chapter 11. The Future\",\"link\":\"/chapter_11\"},{\"text\":\"About the Author\",\"link\":\"/about\"},{\"text\":\"Index\",\"link\":\"/index_page\"}]}],\"socialLinks\":[]},\"locales\":{},\"scrollOffset\":134,\"cleanUrls\":false}");</script>
    
  </body>
</html>